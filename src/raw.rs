/* automatically generated by rust-bindgen 0.56.0 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage, Align> {
    storage: Storage,
    align: [Align; 0],
}
impl<Storage, Align> __BindgenBitfieldUnit<Storage, Align> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage, align: [] }
    }
}
impl<Storage, Align> __BindgenBitfieldUnit<Storage, Align>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
pub type Boolean = bool;
pub type ushort = ::std::os::raw::c_ushort;
pub type uchar = ::std::os::raw::c_uchar;
pub type ulong = ::std::os::raw::c_ulong;
pub type std_string = [u64; 4usize];
pub type std_streamoff = u64;
pub type std_streampos = u8;
pub type std_streambuf = [u64; 8usize];
pub type std_ios_base_openmode = u32;
pub type std_ios_base_seekdir = u32;
pub type size_t = ::std::os::raw::c_ulong;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __uint32_t = ::std::os::raw::c_uint;
pub const StreamableInit_streamableInit: StreamableInit = 0;
pub type StreamableInit = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TStreamableTypes {
    _unused: [u8; 0],
}
pub type ccIndex = ::std::os::raw::c_int;
pub type ccTestFunc = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
    ) -> Boolean,
>;
pub type ccAppFunc = ::std::option::Option<
    unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void, arg2: *mut ::std::os::raw::c_void),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TSpan<T> {
    pub ptr: *mut T,
    pub len: size_t,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T>>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TStringView {
    pub str_: *const ::std::os::raw::c_char,
    pub len: size_t,
}
#[test]
fn bindgen_test_layout_TStringView() {
    assert_eq!(
        ::std::mem::size_of::<TStringView>(),
        16usize,
        concat!("Size of: ", stringify!(TStringView))
    );
    assert_eq!(
        ::std::mem::align_of::<TStringView>(),
        8usize,
        concat!("Alignment of ", stringify!(TStringView))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TStringView>())).str_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TStringView),
            "::",
            stringify!(str_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TStringView>())).len as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(TStringView),
            "::",
            stringify!(len)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN11TStringViewC1ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
    pub fn TStringView_TStringView(this: *mut TStringView, text: *const std_string);
}
impl TStringView {
    #[inline]
    pub unsafe fn new(text: *const std_string) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        TStringView_TStringView(__bindgen_tmp.as_mut_ptr(), text);
        __bindgen_tmp.assume_init()
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct trivially_convertible {
    pub _address: u8,
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct TCellAttribs {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u8>,
}
#[test]
fn bindgen_test_layout_TCellAttribs() {
    assert_eq!(
        ::std::mem::size_of::<TCellAttribs>(),
        2usize,
        concat!("Size of: ", stringify!(TCellAttribs))
    );
    assert_eq!(
        ::std::mem::align_of::<TCellAttribs>(),
        2usize,
        concat!("Alignment of ", stringify!(TCellAttribs))
    );
}
impl TCellAttribs {
    #[inline]
    pub fn fgBlue(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_fgBlue(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fgGreen(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_fgGreen(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fgRed(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_fgRed(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fgBright(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_fgBright(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bgBlue(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_bgBlue(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bgGreen(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_bgGreen(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bgRed(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_bgRed(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bgBright(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_bgBright(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fgDefault(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_fgDefault(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bgDefault(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_bgDefault(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bold(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_bold(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn italic(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_italic(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn underline(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_underline(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reverse(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_reverse(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn shadow(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_shadow(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        fgBlue: u8,
        fgGreen: u8,
        fgRed: u8,
        fgBright: u8,
        bgBlue: u8,
        bgGreen: u8,
        bgRed: u8,
        bgBright: u8,
        fgDefault: u8,
        bgDefault: u8,
        bold: u8,
        italic: u8,
        underline: u8,
        reverse: u8,
        shadow: u8,
    ) -> __BindgenBitfieldUnit<[u8; 2usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let fgBlue: u8 = unsafe { ::std::mem::transmute(fgBlue) };
            fgBlue as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let fgGreen: u8 = unsafe { ::std::mem::transmute(fgGreen) };
            fgGreen as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let fgRed: u8 = unsafe { ::std::mem::transmute(fgRed) };
            fgRed as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let fgBright: u8 = unsafe { ::std::mem::transmute(fgBright) };
            fgBright as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let bgBlue: u8 = unsafe { ::std::mem::transmute(bgBlue) };
            bgBlue as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let bgGreen: u8 = unsafe { ::std::mem::transmute(bgGreen) };
            bgGreen as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let bgRed: u8 = unsafe { ::std::mem::transmute(bgRed) };
            bgRed as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let bgBright: u8 = unsafe { ::std::mem::transmute(bgBright) };
            bgBright as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let fgDefault: u8 = unsafe { ::std::mem::transmute(fgDefault) };
            fgDefault as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let bgDefault: u8 = unsafe { ::std::mem::transmute(bgDefault) };
            bgDefault as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let bold: u8 = unsafe { ::std::mem::transmute(bold) };
            bold as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let italic: u8 = unsafe { ::std::mem::transmute(italic) };
            italic as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let underline: u8 = unsafe { ::std::mem::transmute(underline) };
            underline as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let reverse: u8 = unsafe { ::std::mem::transmute(reverse) };
            reverse as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let shadow: u8 = unsafe { ::std::mem::transmute(shadow) };
            shadow as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct TCellChar {
    pub bytes: [u8; 12usize],
}
#[test]
fn bindgen_test_layout_TCellChar() {
    assert_eq!(
        ::std::mem::size_of::<TCellChar>(),
        12usize,
        concat!("Size of: ", stringify!(TCellChar))
    );
    assert_eq!(
        ::std::mem::align_of::<TCellChar>(),
        4usize,
        concat!("Alignment of ", stringify!(TCellChar))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TCellChar>())).bytes as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TCellChar),
            "::",
            stringify!(bytes)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TScreenCell {
    pub Char: TCellChar,
    pub Attr: TCellAttribs,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub __bindgen_padding_0: u8,
}
pub const TScreenCell_wideCharTrail: u32 = 4294967294;
#[test]
fn bindgen_test_layout_TScreenCell() {
    assert_eq!(
        ::std::mem::size_of::<TScreenCell>(),
        16usize,
        concat!("Size of: ", stringify!(TScreenCell))
    );
    assert_eq!(
        ::std::mem::align_of::<TScreenCell>(),
        4usize,
        concat!("Alignment of ", stringify!(TScreenCell))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TScreenCell>())).Char as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TScreenCell),
            "::",
            stringify!(Char)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TScreenCell>())).Attr as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(TScreenCell),
            "::",
            stringify!(Attr)
        )
    );
}
impl TScreenCell {
    #[inline]
    pub fn extraWidth(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_extraWidth(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(extraWidth: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let extraWidth: u8 = unsafe { ::std::mem::transmute(extraWidth) };
            extraWidth as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TMenu {
    _unused: [u8; 0],
}
#[repr(C)]
pub struct TObject__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct TObject {
    pub vtable_: *const TObject__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_TObject() {
    assert_eq!(
        ::std::mem::size_of::<TObject>(),
        8usize,
        concat!("Size of: ", stringify!(TObject))
    );
    assert_eq!(
        ::std::mem::align_of::<TObject>(),
        8usize,
        concat!("Alignment of ", stringify!(TObject))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN7TObject7destroyEPS_"]
    pub fn TObject_destroy(arg1: *mut TObject);
}
impl TObject {
    #[inline]
    pub unsafe fn destroy(arg1: *mut TObject) {
        TObject_destroy(arg1)
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN7TObjectD1Ev"]
    pub fn TObject_TObject_destructor(this: *mut TObject);
}
extern "C" {
    #[link_name = "\u{1}_ZN7TObject8shutDownEv"]
    pub fn TObject_shutDown(this: *mut ::std::os::raw::c_void);
}
#[repr(C)]
#[derive(Debug)]
pub struct TNSCollection {
    pub _base: TObject,
    pub items: *mut *mut ::std::os::raw::c_void,
    pub count: ccIndex,
    pub limit: ccIndex,
    pub delta: ccIndex,
    pub shouldDelete: Boolean,
}
#[test]
fn bindgen_test_layout_TNSCollection() {
    assert_eq!(
        ::std::mem::size_of::<TNSCollection>(),
        32usize,
        concat!("Size of: ", stringify!(TNSCollection))
    );
    assert_eq!(
        ::std::mem::align_of::<TNSCollection>(),
        8usize,
        concat!("Alignment of ", stringify!(TNSCollection))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TNSCollection>())).items as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(TNSCollection),
            "::",
            stringify!(items)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TNSCollection>())).count as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(TNSCollection),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TNSCollection>())).limit as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(TNSCollection),
            "::",
            stringify!(limit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TNSCollection>())).delta as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(TNSCollection),
            "::",
            stringify!(delta)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TNSCollection>())).shouldDelete as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(TNSCollection),
            "::",
            stringify!(shouldDelete)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN13TNSCollection2atEi"]
    pub fn TNSCollection_at(
        this: *mut TNSCollection,
        index: ccIndex,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[link_name = "\u{1}_ZN13TNSCollection6atFreeEi"]
    pub fn TNSCollection_atFree(this: *mut TNSCollection, index: ccIndex);
}
extern "C" {
    #[link_name = "\u{1}_ZN13TNSCollection8atRemoveEi"]
    pub fn TNSCollection_atRemove(this: *mut TNSCollection, index: ccIndex);
}
extern "C" {
    #[link_name = "\u{1}_ZN13TNSCollection6removeEPv"]
    pub fn TNSCollection_remove(this: *mut TNSCollection, item: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[link_name = "\u{1}_ZN13TNSCollection9removeAllEv"]
    pub fn TNSCollection_removeAll(this: *mut TNSCollection);
}
extern "C" {
    #[link_name = "\u{1}_ZN13TNSCollection4freeEPv"]
    pub fn TNSCollection_free(this: *mut TNSCollection, item: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[link_name = "\u{1}_ZN13TNSCollection7freeAllEv"]
    pub fn TNSCollection_freeAll(this: *mut TNSCollection);
}
extern "C" {
    #[link_name = "\u{1}_ZN13TNSCollection8atInsertEiPv"]
    pub fn TNSCollection_atInsert(
        this: *mut TNSCollection,
        index: ccIndex,
        item: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN13TNSCollection5atPutEiPv"]
    pub fn TNSCollection_atPut(
        this: *mut TNSCollection,
        index: ccIndex,
        item: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN13TNSCollection9firstThatEPFbPvS0_ES0_"]
    pub fn TNSCollection_firstThat(
        this: *mut TNSCollection,
        Test: ccTestFunc,
        arg: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[link_name = "\u{1}_ZN13TNSCollection8lastThatEPFbPvS0_ES0_"]
    pub fn TNSCollection_lastThat(
        this: *mut TNSCollection,
        Test: ccTestFunc,
        arg: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[link_name = "\u{1}_ZN13TNSCollection7forEachEPFvPvS0_ES0_"]
    pub fn TNSCollection_forEach(
        this: *mut TNSCollection,
        action: ccAppFunc,
        arg: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN13TNSCollection4packEv"]
    pub fn TNSCollection_pack(this: *mut TNSCollection);
}
extern "C" {
    #[link_name = "\u{1}_ZN13TNSCollectionC1Eii"]
    pub fn TNSCollection_TNSCollection(this: *mut TNSCollection, aLimit: ccIndex, aDelta: ccIndex);
}
extern "C" {
    #[link_name = "\u{1}_ZN13TNSCollectionC1Ev"]
    pub fn TNSCollection_TNSCollection1(this: *mut TNSCollection);
}
impl TNSCollection {
    #[inline]
    pub unsafe fn at(&mut self, index: ccIndex) -> *mut ::std::os::raw::c_void {
        TNSCollection_at(self, index)
    }
    #[inline]
    pub unsafe fn atFree(&mut self, index: ccIndex) {
        TNSCollection_atFree(self, index)
    }
    #[inline]
    pub unsafe fn atRemove(&mut self, index: ccIndex) {
        TNSCollection_atRemove(self, index)
    }
    #[inline]
    pub unsafe fn remove(&mut self, item: *mut ::std::os::raw::c_void) {
        TNSCollection_remove(self, item)
    }
    #[inline]
    pub unsafe fn removeAll(&mut self) {
        TNSCollection_removeAll(self)
    }
    #[inline]
    pub unsafe fn free(&mut self, item: *mut ::std::os::raw::c_void) {
        TNSCollection_free(self, item)
    }
    #[inline]
    pub unsafe fn freeAll(&mut self) {
        TNSCollection_freeAll(self)
    }
    #[inline]
    pub unsafe fn atInsert(&mut self, index: ccIndex, item: *mut ::std::os::raw::c_void) {
        TNSCollection_atInsert(self, index, item)
    }
    #[inline]
    pub unsafe fn atPut(&mut self, index: ccIndex, item: *mut ::std::os::raw::c_void) {
        TNSCollection_atPut(self, index, item)
    }
    #[inline]
    pub unsafe fn firstThat(
        &mut self,
        Test: ccTestFunc,
        arg: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void {
        TNSCollection_firstThat(self, Test, arg)
    }
    #[inline]
    pub unsafe fn lastThat(
        &mut self,
        Test: ccTestFunc,
        arg: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void {
        TNSCollection_lastThat(self, Test, arg)
    }
    #[inline]
    pub unsafe fn forEach(&mut self, action: ccAppFunc, arg: *mut ::std::os::raw::c_void) {
        TNSCollection_forEach(self, action, arg)
    }
    #[inline]
    pub unsafe fn pack(&mut self) {
        TNSCollection_pack(self)
    }
    #[inline]
    pub unsafe fn new(aLimit: ccIndex, aDelta: ccIndex) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        TNSCollection_TNSCollection(__bindgen_tmp.as_mut_ptr(), aLimit, aDelta);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        TNSCollection_TNSCollection1(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN13TNSCollectionD1Ev"]
    pub fn TNSCollection_TNSCollection_destructor(this: *mut TNSCollection);
}
extern "C" {
    #[link_name = "\u{1}_ZN13TNSCollection8shutDownEv"]
    pub fn TNSCollection_shutDown(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[link_name = "\u{1}_ZN13TNSCollection7indexOfEPv"]
    pub fn TNSCollection_indexOf(
        this: *mut ::std::os::raw::c_void,
        item: *mut ::std::os::raw::c_void,
    ) -> ccIndex;
}
extern "C" {
    #[link_name = "\u{1}_ZN13TNSCollection6insertEPv"]
    pub fn TNSCollection_insert(
        this: *mut ::std::os::raw::c_void,
        item: *mut ::std::os::raw::c_void,
    ) -> ccIndex;
}
extern "C" {
    #[link_name = "\u{1}_ZN13TNSCollection5errorEii"]
    pub fn TNSCollection_error(this: *mut ::std::os::raw::c_void, code: ccIndex, info: ccIndex);
}
extern "C" {
    #[link_name = "\u{1}_ZN13TNSCollection8setLimitEi"]
    pub fn TNSCollection_setLimit(this: *mut ::std::os::raw::c_void, aLimit: ccIndex);
}
#[repr(C)]
#[derive(Debug)]
pub struct TNSSortedCollection {
    pub __bindgen_padding_0: [u8; 8usize],
    pub duplicates: Boolean,
    pub __bindgen_padding_1: [u64; 4usize],
}
#[test]
fn bindgen_test_layout_TNSSortedCollection() {
    assert_eq!(
        ::std::mem::size_of::<TNSSortedCollection>(),
        48usize,
        concat!("Size of: ", stringify!(TNSSortedCollection))
    );
    assert_eq!(
        ::std::mem::align_of::<TNSSortedCollection>(),
        8usize,
        concat!("Alignment of ", stringify!(TNSSortedCollection))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TNSSortedCollection>())).duplicates as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(TNSSortedCollection),
            "::",
            stringify!(duplicates)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN19TNSSortedCollection6searchEPvRi"]
    pub fn TNSSortedCollection_search(
        this: *mut ::std::os::raw::c_void,
        key: *mut ::std::os::raw::c_void,
        index: *mut ccIndex,
    ) -> Boolean;
}
extern "C" {
    #[link_name = "\u{1}_ZTv0_n40_N19TNSSortedCollection7indexOfEPv"]
    pub fn TNSSortedCollection_indexOf(
        this: *mut ::std::os::raw::c_void,
        item: *mut ::std::os::raw::c_void,
    ) -> ccIndex;
}
extern "C" {
    #[link_name = "\u{1}_ZTv0_n48_N19TNSSortedCollection6insertEPv"]
    pub fn TNSSortedCollection_insert(
        this: *mut ::std::os::raw::c_void,
        item: *mut ::std::os::raw::c_void,
    ) -> ccIndex;
}
extern "C" {
    #[link_name = "\u{1}_ZN19TNSSortedCollection5keyOfEPv"]
    pub fn TNSSortedCollection_keyOf(
        this: *mut ::std::os::raw::c_void,
        item: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
pub type P_id_type = ::std::os::raw::c_uint;
#[repr(C)]
pub struct TStreamable__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TStreamable {
    pub vtable_: *const TStreamable__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_TStreamable() {
    assert_eq!(
        ::std::mem::size_of::<TStreamable>(),
        8usize,
        concat!("Size of: ", stringify!(TStreamable))
    );
    assert_eq!(
        ::std::mem::align_of::<TStreamable>(),
        8usize,
        concat!("Alignment of ", stringify!(TStreamable))
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct TPWrittenObjects {
    pub _base: TNSSortedCollection,
    pub curId: P_id_type,
}
#[test]
fn bindgen_test_layout_TPWrittenObjects() {
    assert_eq!(
        ::std::mem::size_of::<TPWrittenObjects>(),
        48usize,
        concat!("Size of: ", stringify!(TPWrittenObjects))
    );
    assert_eq!(
        ::std::mem::align_of::<TPWrittenObjects>(),
        8usize,
        concat!("Alignment of ", stringify!(TPWrittenObjects))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TPWrittenObjects>())).curId as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(TPWrittenObjects),
            "::",
            stringify!(curId)
        )
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct TPReadObjects {
    pub _base: TNSCollection,
    pub curId: P_id_type,
}
#[test]
fn bindgen_test_layout_TPReadObjects() {
    assert_eq!(
        ::std::mem::size_of::<TPReadObjects>(),
        40usize,
        concat!("Size of: ", stringify!(TPReadObjects))
    );
    assert_eq!(
        ::std::mem::align_of::<TPReadObjects>(),
        8usize,
        concat!("Alignment of ", stringify!(TPReadObjects))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TPReadObjects>())).curId as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(TPReadObjects),
            "::",
            stringify!(curId)
        )
    );
}
#[repr(C)]
pub struct pstream__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct pstream {
    pub vtable_: *const pstream__bindgen_vtable,
    pub bp: *mut std_streambuf,
    pub state: ::std::os::raw::c_int,
}
pub const pstream_StreamableError_peNotRegistered: pstream_StreamableError = 0;
pub const pstream_StreamableError_peInvalidType: pstream_StreamableError = 1;
pub type pstream_StreamableError = ::std::os::raw::c_uint;
pub const pstream_PointerTypes_ptNull: pstream_PointerTypes = 0;
pub const pstream_PointerTypes_ptIndexed: pstream_PointerTypes = 1;
pub const pstream_PointerTypes_ptObject: pstream_PointerTypes = 2;
pub type pstream_PointerTypes = ::std::os::raw::c_uint;
pub use self::std_ios_base_openmode as pstream_openmode;
pub use self::std_ios_base_seekdir as pstream_seekdir;
extern "C" {
    #[link_name = "\u{1}_ZN7pstream5typesE"]
    pub static mut pstream_types: *mut TStreamableTypes;
}
#[test]
fn bindgen_test_layout_pstream() {
    assert_eq!(
        ::std::mem::size_of::<pstream>(),
        24usize,
        concat!("Size of: ", stringify!(pstream))
    );
    assert_eq!(
        ::std::mem::align_of::<pstream>(),
        8usize,
        concat!("Alignment of ", stringify!(pstream))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pstream>())).bp as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pstream),
            "::",
            stringify!(bp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pstream>())).state as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(pstream),
            "::",
            stringify!(state)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK7pstream7rdstateEv"]
    pub fn pstream_rdstate(this: *const pstream) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZNK7pstream3eofEv"]
    pub fn pstream_eof(this: *const pstream) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZNK7pstream4failEv"]
    pub fn pstream_fail(this: *const pstream) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZNK7pstream3badEv"]
    pub fn pstream_bad(this: *const pstream) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZNK7pstream4goodEv"]
    pub fn pstream_good(this: *const pstream) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZN7pstream5clearEi"]
    pub fn pstream_clear(this: *mut pstream, arg1: ::std::os::raw::c_int);
}
extern "C" {
    #[link_name = "\u{1}_ZNK7pstream5rdbufEv"]
    pub fn pstream_rdbuf(this: *const pstream) -> *mut std_streambuf;
}
extern "C" {
    #[link_name = "\u{1}_ZN7pstream9initTypesEv"]
    pub fn pstream_initTypes();
}
extern "C" {
    #[link_name = "\u{1}_ZN7pstream5errorENS_15StreamableErrorE"]
    pub fn pstream_error(this: *mut pstream, arg1: pstream_StreamableError);
}
extern "C" {
    #[link_name = "\u{1}_ZN7pstream5errorENS_15StreamableErrorERK11TStreamable"]
    pub fn pstream_error1(
        this: *mut pstream,
        arg1: pstream_StreamableError,
        arg2: *const TStreamable,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN7pstream12registerTypeEP16TStreamableClass"]
    pub fn pstream_registerType(ts: *mut TStreamableClass);
}
extern "C" {
    #[link_name = "\u{1}_ZN7pstream4initEPSt15basic_streambufIcSt11char_traitsIcEE"]
    pub fn pstream_init(this: *mut pstream, arg1: *mut std_streambuf);
}
extern "C" {
    #[link_name = "\u{1}_ZN7pstream8setstateEi"]
    pub fn pstream_setstate(this: *mut pstream, arg1: ::std::os::raw::c_int);
}
extern "C" {
    #[link_name = "\u{1}_ZN7pstreamC1EPSt15basic_streambufIcSt11char_traitsIcEE"]
    pub fn pstream_pstream(this: *mut pstream, arg1: *mut std_streambuf);
}
extern "C" {
    #[link_name = "\u{1}_ZN7pstreamC1Ev"]
    pub fn pstream_pstream1(this: *mut pstream);
}
impl pstream {
    #[inline]
    pub unsafe fn rdstate(&self) -> ::std::os::raw::c_int {
        pstream_rdstate(self)
    }
    #[inline]
    pub unsafe fn eof(&self) -> ::std::os::raw::c_int {
        pstream_eof(self)
    }
    #[inline]
    pub unsafe fn fail(&self) -> ::std::os::raw::c_int {
        pstream_fail(self)
    }
    #[inline]
    pub unsafe fn bad(&self) -> ::std::os::raw::c_int {
        pstream_bad(self)
    }
    #[inline]
    pub unsafe fn good(&self) -> ::std::os::raw::c_int {
        pstream_good(self)
    }
    #[inline]
    pub unsafe fn clear(&mut self, arg1: ::std::os::raw::c_int) {
        pstream_clear(self, arg1)
    }
    #[inline]
    pub unsafe fn rdbuf(&self) -> *mut std_streambuf {
        pstream_rdbuf(self)
    }
    #[inline]
    pub unsafe fn initTypes() {
        pstream_initTypes()
    }
    #[inline]
    pub unsafe fn error(&mut self, arg1: pstream_StreamableError) {
        pstream_error(self, arg1)
    }
    #[inline]
    pub unsafe fn error1(&mut self, arg1: pstream_StreamableError, arg2: *const TStreamable) {
        pstream_error1(self, arg1, arg2)
    }
    #[inline]
    pub unsafe fn registerType(ts: *mut TStreamableClass) {
        pstream_registerType(ts)
    }
    #[inline]
    pub unsafe fn init(&mut self, arg1: *mut std_streambuf) {
        pstream_init(self, arg1)
    }
    #[inline]
    pub unsafe fn setstate(&mut self, arg1: ::std::os::raw::c_int) {
        pstream_setstate(self, arg1)
    }
    #[inline]
    pub unsafe fn new(arg1: *mut std_streambuf) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        pstream_pstream(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        pstream_pstream1(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN7pstreamD1Ev"]
    pub fn pstream_pstream_destructor(this: *mut pstream);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TStreamableClass {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug)]
pub struct ipstream {
    pub __bindgen_padding_0: u64,
    pub objs: TPReadObjects,
    pub __bindgen_padding_1: [u64; 3usize],
}
#[test]
fn bindgen_test_layout_ipstream() {
    assert_eq!(
        ::std::mem::size_of::<ipstream>(),
        72usize,
        concat!("Size of: ", stringify!(ipstream))
    );
    assert_eq!(
        ::std::mem::align_of::<ipstream>(),
        8usize,
        concat!("Alignment of ", stringify!(ipstream))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ipstream>())).objs as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ipstream),
            "::",
            stringify!(objs)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN8ipstream5tellgEv"]
    pub fn ipstream_tellg(this: *mut ipstream) -> std_streampos;
}
extern "C" {
    #[link_name = "\u{1}_ZN8ipstream5seekgESt4fposI11__mbstate_tE"]
    pub fn ipstream_seekg(this: *mut ipstream, arg1: std_streampos) -> *mut ipstream;
}
extern "C" {
    #[link_name = "\u{1}_ZN8ipstream5seekgElSt12_Ios_Seekdir"]
    pub fn ipstream_seekg1(
        this: *mut ipstream,
        arg1: std_streamoff,
        arg2: pstream_seekdir,
    ) -> *mut ipstream;
}
extern "C" {
    #[link_name = "\u{1}_ZN8ipstream8readByteEv"]
    pub fn ipstream_readByte(this: *mut ipstream) -> uchar;
}
extern "C" {
    #[link_name = "\u{1}_ZN8ipstream9readBytesEPvm"]
    pub fn ipstream_readBytes(this: *mut ipstream, arg1: *mut ::std::os::raw::c_void, arg2: size_t);
}
extern "C" {
    #[link_name = "\u{1}_ZN8ipstream8readWordEv"]
    pub fn ipstream_readWord(this: *mut ipstream) -> ushort;
}
extern "C" {
    #[link_name = "\u{1}_ZN8ipstream10readStringEv"]
    pub fn ipstream_readString(this: *mut ipstream) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_ZN8ipstream10readStringEPcj"]
    pub fn ipstream_readString1(
        this: *mut ipstream,
        arg1: *mut ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_uint,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_ZN8ipstream10readPrefixEv"]
    pub fn ipstream_readPrefix(this: *mut ipstream) -> *const TStreamableClass;
}
extern "C" {
    #[link_name = "\u{1}_ZN8ipstream8readDataEPK16TStreamableClassP11TStreamable"]
    pub fn ipstream_readData(
        this: *mut ipstream,
        arg1: *const TStreamableClass,
        arg2: *mut TStreamable,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[link_name = "\u{1}_ZN8ipstream10readSuffixEv"]
    pub fn ipstream_readSuffix(this: *mut ipstream);
}
extern "C" {
    #[link_name = "\u{1}_ZN8ipstream4findEj"]
    pub fn ipstream_find(this: *mut ipstream, arg1: P_id_type) -> *const ::std::os::raw::c_void;
}
extern "C" {
    #[link_name = "\u{1}_ZN8ipstream14registerObjectEPKv"]
    pub fn ipstream_registerObject(this: *mut ipstream, adr: *const ::std::os::raw::c_void);
}
extern "C" {
    #[link_name = "\u{1}_ZN8ipstreamC1EPSt15basic_streambufIcSt11char_traitsIcEE"]
    pub fn ipstream_ipstream(this: *mut ipstream, arg1: *mut std_streambuf);
}
extern "C" {
    #[link_name = "\u{1}_ZN8ipstreamC1Ev"]
    pub fn ipstream_ipstream1(this: *mut ipstream);
}
impl ipstream {
    #[inline]
    pub unsafe fn tellg(&mut self) -> std_streampos {
        ipstream_tellg(self)
    }
    #[inline]
    pub unsafe fn seekg(&mut self, arg1: std_streampos) -> *mut ipstream {
        ipstream_seekg(self, arg1)
    }
    #[inline]
    pub unsafe fn seekg1(&mut self, arg1: std_streamoff, arg2: pstream_seekdir) -> *mut ipstream {
        ipstream_seekg1(self, arg1, arg2)
    }
    #[inline]
    pub unsafe fn readByte(&mut self) -> uchar {
        ipstream_readByte(self)
    }
    #[inline]
    pub unsafe fn readBytes(&mut self, arg1: *mut ::std::os::raw::c_void, arg2: size_t) {
        ipstream_readBytes(self, arg1, arg2)
    }
    #[inline]
    pub unsafe fn readWord(&mut self) -> ushort {
        ipstream_readWord(self)
    }
    #[inline]
    pub unsafe fn readString(&mut self) -> *mut ::std::os::raw::c_char {
        ipstream_readString(self)
    }
    #[inline]
    pub unsafe fn readString1(
        &mut self,
        arg1: *mut ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_uint,
    ) -> *mut ::std::os::raw::c_char {
        ipstream_readString1(self, arg1, arg2)
    }
    #[inline]
    pub unsafe fn readPrefix(&mut self) -> *const TStreamableClass {
        ipstream_readPrefix(self)
    }
    #[inline]
    pub unsafe fn readData(
        &mut self,
        arg1: *const TStreamableClass,
        arg2: *mut TStreamable,
    ) -> *mut ::std::os::raw::c_void {
        ipstream_readData(self, arg1, arg2)
    }
    #[inline]
    pub unsafe fn readSuffix(&mut self) {
        ipstream_readSuffix(self)
    }
    #[inline]
    pub unsafe fn find(&mut self, arg1: P_id_type) -> *const ::std::os::raw::c_void {
        ipstream_find(self, arg1)
    }
    #[inline]
    pub unsafe fn registerObject(&mut self, adr: *const ::std::os::raw::c_void) {
        ipstream_registerObject(self, adr)
    }
    #[inline]
    pub unsafe fn new(arg1: *mut std_streambuf) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        ipstream_ipstream(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        ipstream_ipstream1(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN8ipstreamD1Ev"]
    pub fn ipstream_ipstream_destructor(this: *mut ipstream);
}
#[repr(C)]
#[derive(Debug)]
pub struct opstream {
    pub __bindgen_padding_0: u64,
    pub objs: *mut TPWrittenObjects,
    pub __bindgen_padding_1: [u64; 3usize],
}
#[test]
fn bindgen_test_layout_opstream() {
    assert_eq!(
        ::std::mem::size_of::<opstream>(),
        40usize,
        concat!("Size of: ", stringify!(opstream))
    );
    assert_eq!(
        ::std::mem::align_of::<opstream>(),
        8usize,
        concat!("Alignment of ", stringify!(opstream))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<opstream>())).objs as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(opstream),
            "::",
            stringify!(objs)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN8opstream5tellpEv"]
    pub fn opstream_tellp(this: *mut opstream) -> std_streampos;
}
extern "C" {
    #[link_name = "\u{1}_ZN8opstream5seekpESt4fposI11__mbstate_tE"]
    pub fn opstream_seekp(this: *mut opstream, arg1: std_streampos) -> *mut opstream;
}
extern "C" {
    #[link_name = "\u{1}_ZN8opstream5seekpElSt12_Ios_Seekdir"]
    pub fn opstream_seekp1(
        this: *mut opstream,
        arg1: std_streamoff,
        arg2: pstream_seekdir,
    ) -> *mut opstream;
}
extern "C" {
    #[link_name = "\u{1}_ZN8opstream5flushEv"]
    pub fn opstream_flush(this: *mut opstream) -> *mut opstream;
}
extern "C" {
    #[link_name = "\u{1}_ZN8opstream9writeByteEh"]
    pub fn opstream_writeByte(this: *mut opstream, arg1: uchar);
}
extern "C" {
    #[link_name = "\u{1}_ZN8opstream10writeBytesEPKvm"]
    pub fn opstream_writeBytes(
        this: *mut opstream,
        arg1: *const ::std::os::raw::c_void,
        arg2: size_t,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN8opstream9writeWordEt"]
    pub fn opstream_writeWord(this: *mut opstream, arg1: ushort);
}
extern "C" {
    #[link_name = "\u{1}_ZN8opstream11writeStringEPKc"]
    pub fn opstream_writeString(this: *mut opstream, arg1: *const ::std::os::raw::c_char);
}
extern "C" {
    #[link_name = "\u{1}_ZN8opstream11writeStringE11TStringView"]
    pub fn opstream_writeString1(this: *mut opstream, arg1: TStringView);
}
extern "C" {
    #[link_name = "\u{1}_ZN8opstream11writePrefixERK11TStreamable"]
    pub fn opstream_writePrefix(this: *mut opstream, arg1: *const TStreamable);
}
extern "C" {
    #[link_name = "\u{1}_ZN8opstream9writeDataER11TStreamable"]
    pub fn opstream_writeData(this: *mut opstream, arg1: *mut TStreamable);
}
extern "C" {
    #[link_name = "\u{1}_ZN8opstream11writeSuffixERK11TStreamable"]
    pub fn opstream_writeSuffix(this: *mut opstream, arg1: *const TStreamable);
}
extern "C" {
    #[link_name = "\u{1}_ZN8opstream4findEPKv"]
    pub fn opstream_find(this: *mut opstream, adr: *const ::std::os::raw::c_void) -> P_id_type;
}
extern "C" {
    #[link_name = "\u{1}_ZN8opstream14registerObjectEPKv"]
    pub fn opstream_registerObject(this: *mut opstream, adr: *const ::std::os::raw::c_void);
}
extern "C" {
    #[link_name = "\u{1}_ZN8opstreamC1EPSt15basic_streambufIcSt11char_traitsIcEE"]
    pub fn opstream_opstream(this: *mut opstream, arg1: *mut std_streambuf);
}
extern "C" {
    #[link_name = "\u{1}_ZN8opstreamC1Ev"]
    pub fn opstream_opstream1(this: *mut opstream);
}
impl opstream {
    #[inline]
    pub unsafe fn tellp(&mut self) -> std_streampos {
        opstream_tellp(self)
    }
    #[inline]
    pub unsafe fn seekp(&mut self, arg1: std_streampos) -> *mut opstream {
        opstream_seekp(self, arg1)
    }
    #[inline]
    pub unsafe fn seekp1(&mut self, arg1: std_streamoff, arg2: pstream_seekdir) -> *mut opstream {
        opstream_seekp1(self, arg1, arg2)
    }
    #[inline]
    pub unsafe fn flush(&mut self) -> *mut opstream {
        opstream_flush(self)
    }
    #[inline]
    pub unsafe fn writeByte(&mut self, arg1: uchar) {
        opstream_writeByte(self, arg1)
    }
    #[inline]
    pub unsafe fn writeBytes(&mut self, arg1: *const ::std::os::raw::c_void, arg2: size_t) {
        opstream_writeBytes(self, arg1, arg2)
    }
    #[inline]
    pub unsafe fn writeWord(&mut self, arg1: ushort) {
        opstream_writeWord(self, arg1)
    }
    #[inline]
    pub unsafe fn writeString(&mut self, arg1: *const ::std::os::raw::c_char) {
        opstream_writeString(self, arg1)
    }
    #[inline]
    pub unsafe fn writeString1(&mut self, arg1: TStringView) {
        opstream_writeString1(self, arg1)
    }
    #[inline]
    pub unsafe fn writePrefix(&mut self, arg1: *const TStreamable) {
        opstream_writePrefix(self, arg1)
    }
    #[inline]
    pub unsafe fn writeData(&mut self, arg1: *mut TStreamable) {
        opstream_writeData(self, arg1)
    }
    #[inline]
    pub unsafe fn writeSuffix(&mut self, arg1: *const TStreamable) {
        opstream_writeSuffix(self, arg1)
    }
    #[inline]
    pub unsafe fn find(&mut self, adr: *const ::std::os::raw::c_void) -> P_id_type {
        opstream_find(self, adr)
    }
    #[inline]
    pub unsafe fn registerObject(&mut self, adr: *const ::std::os::raw::c_void) {
        opstream_registerObject(self, adr)
    }
    #[inline]
    pub unsafe fn new(arg1: *mut std_streambuf) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        opstream_opstream(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        opstream_opstream1(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN8opstreamD1Ev"]
    pub fn opstream_opstream_destructor(this: *mut opstream);
}
#[repr(C)]
#[derive(Debug)]
pub struct TDrawBuffer {
    pub data: TSpan<TScreenCell>,
}
#[test]
fn bindgen_test_layout_TDrawBuffer() {
    assert_eq!(
        ::std::mem::size_of::<TDrawBuffer>(),
        16usize,
        concat!("Size of: ", stringify!(TDrawBuffer))
    );
    assert_eq!(
        ::std::mem::align_of::<TDrawBuffer>(),
        8usize,
        concat!("Alignment of ", stringify!(TDrawBuffer))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TDrawBuffer>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TDrawBuffer),
            "::",
            stringify!(data)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN11TDrawBuffer8moveCharEtctt"]
    pub fn TDrawBuffer_moveChar(
        this: *mut TDrawBuffer,
        indent: ushort,
        c: ::std::os::raw::c_char,
        attr: ushort,
        count: ushort,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN11TDrawBuffer7moveStrEtPKct"]
    pub fn TDrawBuffer_moveStr(
        this: *mut TDrawBuffer,
        indent: ushort,
        str_: *const ::std::os::raw::c_char,
        attrs: ushort,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN11TDrawBuffer7moveStrEt11TStringViewt"]
    pub fn TDrawBuffer_moveStr1(
        this: *mut TDrawBuffer,
        indent: ushort,
        str_: TStringView,
        attrs: ushort,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN11TDrawBuffer7moveStrEt11TStringViewttt"]
    pub fn TDrawBuffer_moveStr2(
        this: *mut TDrawBuffer,
        indent: ushort,
        str_: TStringView,
        attr: ushort,
        width: ushort,
        begin: ushort,
    ) -> ushort;
}
extern "C" {
    #[link_name = "\u{1}_ZN11TDrawBuffer8moveCStrEtPKct"]
    pub fn TDrawBuffer_moveCStr(
        this: *mut TDrawBuffer,
        indent: ushort,
        str_: *const ::std::os::raw::c_char,
        attrs: ushort,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN11TDrawBuffer8moveCStrEt11TStringViewt"]
    pub fn TDrawBuffer_moveCStr1(
        this: *mut TDrawBuffer,
        indent: ushort,
        str_: TStringView,
        attrs: ushort,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN11TDrawBuffer7moveBufEtPKvtt"]
    pub fn TDrawBuffer_moveBuf(
        this: *mut TDrawBuffer,
        indent: ushort,
        source: *const ::std::os::raw::c_void,
        attr: ushort,
        count: ushort,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN11TDrawBuffer7moveBufEtPK11TScreenCellt"]
    pub fn TDrawBuffer_moveBuf1(
        this: *mut TDrawBuffer,
        indent: ushort,
        source: *const TScreenCell,
        count: ushort,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN11TDrawBuffer12putAttributeEtt"]
    pub fn TDrawBuffer_putAttribute(this: *mut TDrawBuffer, indent: ushort, attr: ushort);
}
extern "C" {
    #[link_name = "\u{1}_ZN11TDrawBuffer7putCharEtt"]
    pub fn TDrawBuffer_putChar(this: *mut TDrawBuffer, indent: ushort, c: ushort);
}
extern "C" {
    #[link_name = "\u{1}_ZNK11TDrawBuffer6lengthEv"]
    pub fn TDrawBuffer_length(this: *const TDrawBuffer) -> size_t;
}
extern "C" {
    #[link_name = "\u{1}_ZN11TDrawBuffer9allocDataEv"]
    pub fn TDrawBuffer_allocData() -> TSpan<TScreenCell>;
}
extern "C" {
    #[link_name = "\u{1}_ZN11TDrawBufferC1Ev"]
    pub fn TDrawBuffer_TDrawBuffer(this: *mut TDrawBuffer);
}
extern "C" {
    #[link_name = "\u{1}_ZN11TDrawBufferD1Ev"]
    pub fn TDrawBuffer_TDrawBuffer_destructor(this: *mut TDrawBuffer);
}
impl TDrawBuffer {
    #[inline]
    pub unsafe fn moveChar(
        &mut self,
        indent: ushort,
        c: ::std::os::raw::c_char,
        attr: ushort,
        count: ushort,
    ) {
        TDrawBuffer_moveChar(self, indent, c, attr, count)
    }
    #[inline]
    pub unsafe fn moveStr(
        &mut self,
        indent: ushort,
        str_: *const ::std::os::raw::c_char,
        attrs: ushort,
    ) {
        TDrawBuffer_moveStr(self, indent, str_, attrs)
    }
    #[inline]
    pub unsafe fn moveStr1(&mut self, indent: ushort, str_: TStringView, attrs: ushort) {
        TDrawBuffer_moveStr1(self, indent, str_, attrs)
    }
    #[inline]
    pub unsafe fn moveStr2(
        &mut self,
        indent: ushort,
        str_: TStringView,
        attr: ushort,
        width: ushort,
        begin: ushort,
    ) -> ushort {
        TDrawBuffer_moveStr2(self, indent, str_, attr, width, begin)
    }
    #[inline]
    pub unsafe fn moveCStr(
        &mut self,
        indent: ushort,
        str_: *const ::std::os::raw::c_char,
        attrs: ushort,
    ) {
        TDrawBuffer_moveCStr(self, indent, str_, attrs)
    }
    #[inline]
    pub unsafe fn moveCStr1(&mut self, indent: ushort, str_: TStringView, attrs: ushort) {
        TDrawBuffer_moveCStr1(self, indent, str_, attrs)
    }
    #[inline]
    pub unsafe fn moveBuf(
        &mut self,
        indent: ushort,
        source: *const ::std::os::raw::c_void,
        attr: ushort,
        count: ushort,
    ) {
        TDrawBuffer_moveBuf(self, indent, source, attr, count)
    }
    #[inline]
    pub unsafe fn moveBuf1(&mut self, indent: ushort, source: *const TScreenCell, count: ushort) {
        TDrawBuffer_moveBuf1(self, indent, source, count)
    }
    #[inline]
    pub unsafe fn putAttribute(&mut self, indent: ushort, attr: ushort) {
        TDrawBuffer_putAttribute(self, indent, attr)
    }
    #[inline]
    pub unsafe fn putChar(&mut self, indent: ushort, c: ushort) {
        TDrawBuffer_putChar(self, indent, c)
    }
    #[inline]
    pub unsafe fn length(&self) -> size_t {
        TDrawBuffer_length(self)
    }
    #[inline]
    pub unsafe fn allocData() -> TSpan<TScreenCell> {
        TDrawBuffer_allocData()
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        TDrawBuffer_TDrawBuffer(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        TDrawBuffer_TDrawBuffer_destructor(self)
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TPoint {
    pub x: ::std::os::raw::c_int,
    pub y: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_TPoint() {
    assert_eq!(
        ::std::mem::size_of::<TPoint>(),
        8usize,
        concat!("Size of: ", stringify!(TPoint))
    );
    assert_eq!(
        ::std::mem::align_of::<TPoint>(),
        4usize,
        concat!("Alignment of ", stringify!(TPoint))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TPoint>())).x as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(TPoint), "::", stringify!(x))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TPoint>())).y as *const _ as usize },
        4usize,
        concat!("Offset of field: ", stringify!(TPoint), "::", stringify!(y))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TRect {
    pub a: TPoint,
    pub b: TPoint,
}
#[test]
fn bindgen_test_layout_TRect() {
    assert_eq!(
        ::std::mem::size_of::<TRect>(),
        16usize,
        concat!("Size of: ", stringify!(TRect))
    );
    assert_eq!(
        ::std::mem::align_of::<TRect>(),
        4usize,
        concat!("Alignment of ", stringify!(TRect))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TRect>())).a as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(TRect), "::", stringify!(a))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TRect>())).b as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(TRect), "::", stringify!(b))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN5TRect4moveEii"]
    pub fn TRect_move(
        this: *mut TRect,
        aDX: ::std::os::raw::c_int,
        aDY: ::std::os::raw::c_int,
    ) -> *mut TRect;
}
extern "C" {
    #[link_name = "\u{1}_ZN5TRect4growEii"]
    pub fn TRect_grow(
        this: *mut TRect,
        aDX: ::std::os::raw::c_int,
        aDY: ::std::os::raw::c_int,
    ) -> *mut TRect;
}
extern "C" {
    #[link_name = "\u{1}_ZN5TRect9intersectERKS_"]
    pub fn TRect_intersect(this: *mut TRect, r: *const TRect) -> *mut TRect;
}
extern "C" {
    #[link_name = "\u{1}_ZN5TRect5UnionERKS_"]
    pub fn TRect_Union(this: *mut TRect, r: *const TRect) -> *mut TRect;
}
extern "C" {
    #[link_name = "\u{1}_ZNK5TRect8containsERK6TPoint"]
    pub fn TRect_contains(this: *const TRect, p: *const TPoint) -> Boolean;
}
extern "C" {
    #[link_name = "\u{1}_ZN5TRect7isEmptyEv"]
    pub fn TRect_isEmpty(this: *mut TRect) -> Boolean;
}
extern "C" {
    #[link_name = "\u{1}_ZN5TRectC1Eiiii"]
    pub fn TRect_TRect(
        this: *mut TRect,
        ax: ::std::os::raw::c_int,
        ay: ::std::os::raw::c_int,
        bx: ::std::os::raw::c_int,
        by: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN5TRectC1E6TPointS0_"]
    pub fn TRect_TRect1(this: *mut TRect, p1: TPoint, p2: TPoint);
}
extern "C" {
    #[link_name = "\u{1}_ZN5TRectC1Ev"]
    pub fn TRect_TRect2(this: *mut TRect);
}
impl TRect {
    #[inline]
    pub unsafe fn move_(
        &mut self,
        aDX: ::std::os::raw::c_int,
        aDY: ::std::os::raw::c_int,
    ) -> *mut TRect {
        TRect_move(self, aDX, aDY)
    }
    #[inline]
    pub unsafe fn grow(
        &mut self,
        aDX: ::std::os::raw::c_int,
        aDY: ::std::os::raw::c_int,
    ) -> *mut TRect {
        TRect_grow(self, aDX, aDY)
    }
    #[inline]
    pub unsafe fn intersect(&mut self, r: *const TRect) -> *mut TRect {
        TRect_intersect(self, r)
    }
    #[inline]
    pub unsafe fn Union(&mut self, r: *const TRect) -> *mut TRect {
        TRect_Union(self, r)
    }
    #[inline]
    pub unsafe fn contains(&self, p: *const TPoint) -> Boolean {
        TRect_contains(self, p)
    }
    #[inline]
    pub unsafe fn isEmpty(&mut self) -> Boolean {
        TRect_isEmpty(self)
    }
    #[inline]
    pub unsafe fn new(
        ax: ::std::os::raw::c_int,
        ay: ::std::os::raw::c_int,
        bx: ::std::os::raw::c_int,
        by: ::std::os::raw::c_int,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        TRect_TRect(__bindgen_tmp.as_mut_ptr(), ax, ay, bx, by);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(p1: TPoint, p2: TPoint) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        TRect_TRect1(__bindgen_tmp.as_mut_ptr(), p1, p2);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new2() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        TRect_TRect2(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MouseEventType {
    pub where_: TPoint,
    pub eventFlags: ulong,
    pub controlKeyState: ulong,
    pub buttons: uchar,
    pub wheel: uchar,
}
#[test]
fn bindgen_test_layout_MouseEventType() {
    assert_eq!(
        ::std::mem::size_of::<MouseEventType>(),
        32usize,
        concat!("Size of: ", stringify!(MouseEventType))
    );
    assert_eq!(
        ::std::mem::align_of::<MouseEventType>(),
        8usize,
        concat!("Alignment of ", stringify!(MouseEventType))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MouseEventType>())).where_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MouseEventType),
            "::",
            stringify!(where_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MouseEventType>())).eventFlags as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MouseEventType),
            "::",
            stringify!(eventFlags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MouseEventType>())).controlKeyState as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(MouseEventType),
            "::",
            stringify!(controlKeyState)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MouseEventType>())).buttons as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(MouseEventType),
            "::",
            stringify!(buttons)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MouseEventType>())).wheel as *const _ as usize },
        25usize,
        concat!(
            "Offset of field: ",
            stringify!(MouseEventType),
            "::",
            stringify!(wheel)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CharScanType {
    pub charCode: uchar,
    pub scanCode: uchar,
}
#[test]
fn bindgen_test_layout_CharScanType() {
    assert_eq!(
        ::std::mem::size_of::<CharScanType>(),
        2usize,
        concat!("Size of: ", stringify!(CharScanType))
    );
    assert_eq!(
        ::std::mem::align_of::<CharScanType>(),
        1usize,
        concat!("Alignment of ", stringify!(CharScanType))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CharScanType>())).charCode as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CharScanType),
            "::",
            stringify!(charCode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CharScanType>())).scanCode as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(CharScanType),
            "::",
            stringify!(scanCode)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct KeyDownEvent {
    pub __bindgen_anon_1: KeyDownEvent__bindgen_ty_1,
    pub controlKeyState: ulong,
    pub text: [::std::os::raw::c_char; 4usize],
    pub textLength: uchar,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union KeyDownEvent__bindgen_ty_1 {
    pub keyCode: ushort,
    pub charScan: CharScanType,
    _bindgen_union_align: u16,
}
#[test]
fn bindgen_test_layout_KeyDownEvent__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<KeyDownEvent__bindgen_ty_1>(),
        2usize,
        concat!("Size of: ", stringify!(KeyDownEvent__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<KeyDownEvent__bindgen_ty_1>(),
        2usize,
        concat!("Alignment of ", stringify!(KeyDownEvent__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<KeyDownEvent__bindgen_ty_1>())).keyCode as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(KeyDownEvent__bindgen_ty_1),
            "::",
            stringify!(keyCode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<KeyDownEvent__bindgen_ty_1>())).charScan as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(KeyDownEvent__bindgen_ty_1),
            "::",
            stringify!(charScan)
        )
    );
}
#[test]
fn bindgen_test_layout_KeyDownEvent() {
    assert_eq!(
        ::std::mem::size_of::<KeyDownEvent>(),
        24usize,
        concat!("Size of: ", stringify!(KeyDownEvent))
    );
    assert_eq!(
        ::std::mem::align_of::<KeyDownEvent>(),
        8usize,
        concat!("Alignment of ", stringify!(KeyDownEvent))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<KeyDownEvent>())).controlKeyState as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(KeyDownEvent),
            "::",
            stringify!(controlKeyState)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<KeyDownEvent>())).text as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(KeyDownEvent),
            "::",
            stringify!(text)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<KeyDownEvent>())).textLength as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(KeyDownEvent),
            "::",
            stringify!(textLength)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct MessageEvent {
    pub command: ushort,
    pub __bindgen_anon_1: MessageEvent__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union MessageEvent__bindgen_ty_1 {
    pub infoPtr: *mut ::std::os::raw::c_void,
    pub infoLong: ::std::os::raw::c_long,
    pub infoWord: ushort,
    pub infoInt: ::std::os::raw::c_short,
    pub infoByte: uchar,
    pub infoChar: ::std::os::raw::c_char,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_MessageEvent__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<MessageEvent__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(MessageEvent__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<MessageEvent__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(MessageEvent__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MessageEvent__bindgen_ty_1>())).infoPtr as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MessageEvent__bindgen_ty_1),
            "::",
            stringify!(infoPtr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MessageEvent__bindgen_ty_1>())).infoLong as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MessageEvent__bindgen_ty_1),
            "::",
            stringify!(infoLong)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MessageEvent__bindgen_ty_1>())).infoWord as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MessageEvent__bindgen_ty_1),
            "::",
            stringify!(infoWord)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MessageEvent__bindgen_ty_1>())).infoInt as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MessageEvent__bindgen_ty_1),
            "::",
            stringify!(infoInt)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MessageEvent__bindgen_ty_1>())).infoByte as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MessageEvent__bindgen_ty_1),
            "::",
            stringify!(infoByte)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MessageEvent__bindgen_ty_1>())).infoChar as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MessageEvent__bindgen_ty_1),
            "::",
            stringify!(infoChar)
        )
    );
}
#[test]
fn bindgen_test_layout_MessageEvent() {
    assert_eq!(
        ::std::mem::size_of::<MessageEvent>(),
        16usize,
        concat!("Size of: ", stringify!(MessageEvent))
    );
    assert_eq!(
        ::std::mem::align_of::<MessageEvent>(),
        8usize,
        concat!("Alignment of ", stringify!(MessageEvent))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MessageEvent>())).command as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MessageEvent),
            "::",
            stringify!(command)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct TEvent {
    pub what: ushort,
    pub __bindgen_anon_1: TEvent__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union TEvent__bindgen_ty_1 {
    pub mouse: MouseEventType,
    pub keyDown: KeyDownEvent,
    pub message: MessageEvent,
    _bindgen_union_align: [u64; 4usize],
}
#[test]
fn bindgen_test_layout_TEvent__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<TEvent__bindgen_ty_1>(),
        32usize,
        concat!("Size of: ", stringify!(TEvent__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<TEvent__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(TEvent__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TEvent__bindgen_ty_1>())).mouse as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TEvent__bindgen_ty_1),
            "::",
            stringify!(mouse)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TEvent__bindgen_ty_1>())).keyDown as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TEvent__bindgen_ty_1),
            "::",
            stringify!(keyDown)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TEvent__bindgen_ty_1>())).message as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TEvent__bindgen_ty_1),
            "::",
            stringify!(message)
        )
    );
}
#[test]
fn bindgen_test_layout_TEvent() {
    assert_eq!(
        ::std::mem::size_of::<TEvent>(),
        40usize,
        concat!("Size of: ", stringify!(TEvent))
    );
    assert_eq!(
        ::std::mem::align_of::<TEvent>(),
        8usize,
        concat!("Alignment of ", stringify!(TEvent))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TEvent>())).what as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TEvent),
            "::",
            stringify!(what)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN6TEvent13getMouseEventEv"]
    pub fn TEvent_getMouseEvent(this: *mut TEvent);
}
extern "C" {
    #[link_name = "\u{1}_ZN6TEvent11getKeyEventEb"]
    pub fn TEvent_getKeyEvent(this: *mut TEvent, blocking: Boolean);
}
impl TEvent {
    #[inline]
    pub unsafe fn getMouseEvent(&mut self) {
        TEvent_getMouseEvent(self)
    }
    #[inline]
    pub unsafe fn getKeyEvent(&mut self, blocking: Boolean) {
        TEvent_getKeyEvent(self, blocking)
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TCommandSet {
    pub cmds: [uchar; 32usize],
}
extern "C" {
    #[link_name = "\u{1}_ZN11TCommandSet5masksE"]
    pub static mut TCommandSet_masks: [::std::os::raw::c_int; 8usize];
}
#[test]
fn bindgen_test_layout_TCommandSet() {
    assert_eq!(
        ::std::mem::size_of::<TCommandSet>(),
        32usize,
        concat!("Size of: ", stringify!(TCommandSet))
    );
    assert_eq!(
        ::std::mem::align_of::<TCommandSet>(),
        1usize,
        concat!("Alignment of ", stringify!(TCommandSet))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TCommandSet>())).cmds as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TCommandSet),
            "::",
            stringify!(cmds)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN11TCommandSet3hasEi"]
    pub fn TCommandSet_has(this: *mut TCommandSet, cmd: ::std::os::raw::c_int) -> Boolean;
}
extern "C" {
    #[link_name = "\u{1}_ZN11TCommandSet10disableCmdEi"]
    pub fn TCommandSet_disableCmd(this: *mut TCommandSet, cmd: ::std::os::raw::c_int);
}
extern "C" {
    #[link_name = "\u{1}_ZN11TCommandSet9enableCmdEi"]
    pub fn TCommandSet_enableCmd(this: *mut TCommandSet, cmd: ::std::os::raw::c_int);
}
extern "C" {
    #[link_name = "\u{1}_ZN11TCommandSet10disableCmdERKS_"]
    pub fn TCommandSet_disableCmd1(this: *mut TCommandSet, arg1: *const TCommandSet);
}
extern "C" {
    #[link_name = "\u{1}_ZN11TCommandSet9enableCmdERKS_"]
    pub fn TCommandSet_enableCmd1(this: *mut TCommandSet, arg1: *const TCommandSet);
}
extern "C" {
    #[link_name = "\u{1}_ZN11TCommandSet7isEmptyEv"]
    pub fn TCommandSet_isEmpty(this: *mut TCommandSet) -> Boolean;
}
extern "C" {
    #[link_name = "\u{1}_ZN11TCommandSetC1Ev"]
    pub fn TCommandSet_TCommandSet(this: *mut TCommandSet);
}
extern "C" {
    #[link_name = "\u{1}_ZN11TCommandSetC1ERKS_"]
    pub fn TCommandSet_TCommandSet1(this: *mut TCommandSet, arg1: *const TCommandSet);
}
impl TCommandSet {
    #[inline]
    pub unsafe fn has(&mut self, cmd: ::std::os::raw::c_int) -> Boolean {
        TCommandSet_has(self, cmd)
    }
    #[inline]
    pub unsafe fn disableCmd(&mut self, cmd: ::std::os::raw::c_int) {
        TCommandSet_disableCmd(self, cmd)
    }
    #[inline]
    pub unsafe fn enableCmd(&mut self, cmd: ::std::os::raw::c_int) {
        TCommandSet_enableCmd(self, cmd)
    }
    #[inline]
    pub unsafe fn disableCmd1(&mut self, arg1: *const TCommandSet) {
        TCommandSet_disableCmd1(self, arg1)
    }
    #[inline]
    pub unsafe fn enableCmd1(&mut self, arg1: *const TCommandSet) {
        TCommandSet_enableCmd1(self, arg1)
    }
    #[inline]
    pub unsafe fn isEmpty(&mut self) -> Boolean {
        TCommandSet_isEmpty(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        TCommandSet_TCommandSet(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(arg1: *const TCommandSet) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        TCommandSet_TCommandSet1(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct TPalette {
    pub data: *mut uchar,
}
#[test]
fn bindgen_test_layout_TPalette() {
    assert_eq!(
        ::std::mem::size_of::<TPalette>(),
        8usize,
        concat!("Size of: ", stringify!(TPalette))
    );
    assert_eq!(
        ::std::mem::align_of::<TPalette>(),
        8usize,
        concat!("Alignment of ", stringify!(TPalette))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TPalette>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPalette),
            "::",
            stringify!(data)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN8TPaletteC1EPKct"]
    pub fn TPalette_TPalette(
        this: *mut TPalette,
        arg1: *const ::std::os::raw::c_char,
        arg2: ushort,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN8TPaletteC1ERKS_"]
    pub fn TPalette_TPalette1(this: *mut TPalette, arg1: *const TPalette);
}
extern "C" {
    #[link_name = "\u{1}_ZN8TPaletteD1Ev"]
    pub fn TPalette_TPalette_destructor(this: *mut TPalette);
}
impl TPalette {
    #[inline]
    pub unsafe fn new(arg1: *const ::std::os::raw::c_char, arg2: ushort) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        TPalette_TPalette(__bindgen_tmp.as_mut_ptr(), arg1, arg2);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(arg1: *const TPalette) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        TPalette_TPalette1(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        TPalette_TPalette_destructor(self)
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct TView {
    pub _base: TObject,
    pub _base_1: TStreamable,
    pub next: *mut TView,
    pub size: TPoint,
    pub options: ushort,
    pub eventMask: ushort,
    pub state: ushort,
    pub origin: TPoint,
    pub cursor: TPoint,
    pub growMode: uchar,
    pub dragMode: uchar,
    pub helpCtx: ushort,
    pub owner: *mut TGroup,
    pub resizeBalance: TPoint,
}
pub const TView_phaseType_phFocused: TView_phaseType = 0;
pub const TView_phaseType_phPreProcess: TView_phaseType = 1;
pub const TView_phaseType_phPostProcess: TView_phaseType = 2;
pub type TView_phaseType = ::std::os::raw::c_uint;
pub const TView_selectMode_normalSelect: TView_selectMode = 0;
pub const TView_selectMode_enterSelect: TView_selectMode = 1;
pub const TView_selectMode_leaveSelect: TView_selectMode = 2;
pub type TView_selectMode = ::std::os::raw::c_uint;
extern "C" {
    #[link_name = "\u{1}_ZN5TView17commandSetChangedE"]
    pub static mut TView_commandSetChanged: Boolean;
}
extern "C" {
    #[link_name = "\u{1}_ZN5TView13curCommandSetE"]
    pub static mut TView_curCommandSet: TCommandSet;
}
extern "C" {
    #[link_name = "\u{1}_ZN5TView11showMarkersE"]
    pub static mut TView_showMarkers: Boolean;
}
extern "C" {
    #[link_name = "\u{1}_ZN5TView9errorAttrE"]
    pub static mut TView_errorAttr: uchar;
}
extern "C" {
    #[link_name = "\u{1}_ZN5TView4nameE"]
    pub static TView_name: *const ::std::os::raw::c_char;
}
#[test]
fn bindgen_test_layout_TView() {
    assert_eq!(
        ::std::mem::size_of::<TView>(),
        80usize,
        concat!("Size of: ", stringify!(TView))
    );
    assert_eq!(
        ::std::mem::align_of::<TView>(),
        8usize,
        concat!("Alignment of ", stringify!(TView))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK5TView9getBoundsEv"]
    pub fn TView_getBounds(this: *const TView) -> TRect;
}
extern "C" {
    #[link_name = "\u{1}_ZNK5TView9getExtentEv"]
    pub fn TView_getExtent(this: *const TView) -> TRect;
}
extern "C" {
    #[link_name = "\u{1}_ZNK5TView11getClipRectEv"]
    pub fn TView_getClipRect(this: *const TView) -> TRect;
}
extern "C" {
    #[link_name = "\u{1}_ZN5TView11mouseInViewE6TPoint"]
    pub fn TView_mouseInView(this: *mut TView, mouse: TPoint) -> Boolean;
}
extern "C" {
    #[link_name = "\u{1}_ZN5TView13containsMouseER6TEvent"]
    pub fn TView_containsMouse(this: *mut TView, event: *mut TEvent) -> Boolean;
}
extern "C" {
    #[link_name = "\u{1}_ZN5TView6locateER5TRect"]
    pub fn TView_locate(this: *mut TView, bounds: *mut TRect);
}
extern "C" {
    #[link_name = "\u{1}_ZN5TView6growToEss"]
    pub fn TView_growTo(this: *mut TView, x: ::std::os::raw::c_short, y: ::std::os::raw::c_short);
}
extern "C" {
    #[link_name = "\u{1}_ZN5TView6moveToEss"]
    pub fn TView_moveTo(this: *mut TView, x: ::std::os::raw::c_short, y: ::std::os::raw::c_short);
}
extern "C" {
    #[link_name = "\u{1}_ZN5TView9setBoundsERK5TRect"]
    pub fn TView_setBounds(this: *mut TView, bounds: *const TRect);
}
extern "C" {
    #[link_name = "\u{1}_ZN5TView4hideEv"]
    pub fn TView_hide(this: *mut TView);
}
extern "C" {
    #[link_name = "\u{1}_ZN5TView4showEv"]
    pub fn TView_show(this: *mut TView);
}
extern "C" {
    #[link_name = "\u{1}_ZN5TView8drawViewEv"]
    pub fn TView_drawView(this: *mut TView);
}
extern "C" {
    #[link_name = "\u{1}_ZN5TView7exposedEv"]
    pub fn TView_exposed(this: *mut TView) -> Boolean;
}
extern "C" {
    #[link_name = "\u{1}_ZN5TView5focusEv"]
    pub fn TView_focus(this: *mut TView) -> Boolean;
}
extern "C" {
    #[link_name = "\u{1}_ZN5TView10hideCursorEv"]
    pub fn TView_hideCursor(this: *mut TView);
}
extern "C" {
    #[link_name = "\u{1}_ZN5TView8drawHideEPS_"]
    pub fn TView_drawHide(this: *mut TView, lastView: *mut TView);
}
extern "C" {
    #[link_name = "\u{1}_ZN5TView8drawShowEPS_"]
    pub fn TView_drawShow(this: *mut TView, lastView: *mut TView);
}
extern "C" {
    #[link_name = "\u{1}_ZN5TView13drawUnderRectER5TRectPS_"]
    pub fn TView_drawUnderRect(this: *mut TView, r: *mut TRect, lastView: *mut TView);
}
extern "C" {
    #[link_name = "\u{1}_ZN5TView13drawUnderViewEbPS_"]
    pub fn TView_drawUnderView(this: *mut TView, doShadow: Boolean, lastView: *mut TView);
}
extern "C" {
    #[link_name = "\u{1}_ZN5TView11blockCursorEv"]
    pub fn TView_blockCursor(this: *mut TView);
}
extern "C" {
    #[link_name = "\u{1}_ZN5TView12normalCursorEv"]
    pub fn TView_normalCursor(this: *mut TView);
}
extern "C" {
    #[link_name = "\u{1}_ZN5TView9setCursorEii"]
    pub fn TView_setCursor(this: *mut TView, x: ::std::os::raw::c_int, y: ::std::os::raw::c_int);
}
extern "C" {
    #[link_name = "\u{1}_ZN5TView10showCursorEv"]
    pub fn TView_showCursor(this: *mut TView);
}
extern "C" {
    #[link_name = "\u{1}_ZN5TView10drawCursorEv"]
    pub fn TView_drawCursor(this: *mut TView);
}
extern "C" {
    #[link_name = "\u{1}_ZN5TView10clearEventER6TEvent"]
    pub fn TView_clearEvent(this: *mut TView, event: *mut TEvent);
}
extern "C" {
    #[link_name = "\u{1}_ZN5TView10eventAvailEv"]
    pub fn TView_eventAvail(this: *mut TView) -> Boolean;
}
extern "C" {
    #[link_name = "\u{1}_ZN5TView14commandEnabledEt"]
    pub fn TView_commandEnabled(command: ushort) -> Boolean;
}
extern "C" {
    #[link_name = "\u{1}_ZN5TView15disableCommandsER11TCommandSet"]
    pub fn TView_disableCommands(commands: *mut TCommandSet);
}
extern "C" {
    #[link_name = "\u{1}_ZN5TView14enableCommandsER11TCommandSet"]
    pub fn TView_enableCommands(commands: *mut TCommandSet);
}
extern "C" {
    #[link_name = "\u{1}_ZN5TView14disableCommandEt"]
    pub fn TView_disableCommand(command: ushort);
}
extern "C" {
    #[link_name = "\u{1}_ZN5TView13enableCommandEt"]
    pub fn TView_enableCommand(command: ushort);
}
extern "C" {
    #[link_name = "\u{1}_ZN5TView11getCommandsER11TCommandSet"]
    pub fn TView_getCommands(commands: *mut TCommandSet);
}
extern "C" {
    #[link_name = "\u{1}_ZN5TView11setCommandsER11TCommandSet"]
    pub fn TView_setCommands(commands: *mut TCommandSet);
}
extern "C" {
    #[link_name = "\u{1}_ZN5TView11setCmdStateER11TCommandSetb"]
    pub fn TView_setCmdState(commands: *mut TCommandSet, enable: Boolean);
}
extern "C" {
    #[link_name = "\u{1}_ZN5TView8getColorEt"]
    pub fn TView_getColor(this: *mut TView, color: ushort) -> ushort;
}
extern "C" {
    #[link_name = "\u{1}_ZN5TView8mapColorEh"]
    pub fn TView_mapColor(this: *mut TView, arg1: uchar) -> uchar;
}
extern "C" {
    #[link_name = "\u{1}_ZNK5TView8getStateEt"]
    pub fn TView_getState(this: *const TView, aState: ushort) -> Boolean;
}
extern "C" {
    #[link_name = "\u{1}_ZN5TView6selectEv"]
    pub fn TView_select(this: *mut TView);
}
extern "C" {
    #[link_name = "\u{1}_ZN5TView8keyEventER6TEvent"]
    pub fn TView_keyEvent(this: *mut TView, event: *mut TEvent);
}
extern "C" {
    #[link_name = "\u{1}_ZN5TView10mouseEventER6TEventt"]
    pub fn TView_mouseEvent(this: *mut TView, event: *mut TEvent, mask: ushort) -> Boolean;
}
extern "C" {
    #[link_name = "\u{1}_ZN5TView9textEventER6TEvent5TSpanIcERm"]
    pub fn TView_textEvent1(
        this: *mut TView,
        event: *mut TEvent,
        dest: TSpan<::std::os::raw::c_char>,
        length: *mut size_t,
    ) -> Boolean;
}
extern "C" {
    #[link_name = "\u{1}_ZN5TView10makeGlobalE6TPoint"]
    pub fn TView_makeGlobal(this: *mut TView, source: TPoint) -> TPoint;
}
extern "C" {
    #[link_name = "\u{1}_ZN5TView9makeLocalE6TPoint"]
    pub fn TView_makeLocal(this: *mut TView, source: TPoint) -> TPoint;
}
extern "C" {
    #[link_name = "\u{1}_ZN5TView8nextViewEv"]
    pub fn TView_nextView(this: *mut TView) -> *mut TView;
}
extern "C" {
    #[link_name = "\u{1}_ZN5TView8prevViewEv"]
    pub fn TView_prevView(this: *mut TView) -> *mut TView;
}
extern "C" {
    #[link_name = "\u{1}_ZN5TView4prevEv"]
    pub fn TView_prev(this: *mut TView) -> *mut TView;
}
extern "C" {
    #[link_name = "\u{1}_ZN5TView9makeFirstEv"]
    pub fn TView_makeFirst(this: *mut TView);
}
extern "C" {
    #[link_name = "\u{1}_ZN5TView12putInFrontOfEPS_"]
    pub fn TView_putInFrontOf(this: *mut TView, Target: *mut TView);
}
extern "C" {
    #[link_name = "\u{1}_ZN5TView7TopViewEv"]
    pub fn TView_TopView(this: *mut TView) -> *mut TView;
}
extern "C" {
    #[link_name = "\u{1}_ZN5TView8writeBufEssssPKv"]
    pub fn TView_writeBuf(
        this: *mut TView,
        x: ::std::os::raw::c_short,
        y: ::std::os::raw::c_short,
        w: ::std::os::raw::c_short,
        h: ::std::os::raw::c_short,
        b: *const ::std::os::raw::c_void,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN5TView8writeBufEssssRK11TDrawBuffer"]
    pub fn TView_writeBuf1(
        this: *mut TView,
        x: ::std::os::raw::c_short,
        y: ::std::os::raw::c_short,
        w: ::std::os::raw::c_short,
        h: ::std::os::raw::c_short,
        b: *const TDrawBuffer,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN5TView9writeCharEsschs"]
    pub fn TView_writeChar(
        this: *mut TView,
        x: ::std::os::raw::c_short,
        y: ::std::os::raw::c_short,
        c: ::std::os::raw::c_char,
        color: uchar,
        count: ::std::os::raw::c_short,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN5TView9writeLineEssssRK11TDrawBuffer"]
    pub fn TView_writeLine(
        this: *mut TView,
        x: ::std::os::raw::c_short,
        y: ::std::os::raw::c_short,
        w: ::std::os::raw::c_short,
        h: ::std::os::raw::c_short,
        b: *const TDrawBuffer,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN5TView9writeLineEssssPKv"]
    pub fn TView_writeLine1(
        this: *mut TView,
        x: ::std::os::raw::c_short,
        y: ::std::os::raw::c_short,
        w: ::std::os::raw::c_short,
        h: ::std::os::raw::c_short,
        b: *const ::std::os::raw::c_void,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN5TView8writeStrEssPKch"]
    pub fn TView_writeStr(
        this: *mut TView,
        x: ::std::os::raw::c_short,
        y: ::std::os::raw::c_short,
        str_: *const ::std::os::raw::c_char,
        color: uchar,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN5TView8writeBufEssssPK11TScreenCell"]
    pub fn TView_writeBuf2(
        this: *mut TView,
        x: ::std::os::raw::c_short,
        y: ::std::os::raw::c_short,
        w: ::std::os::raw::c_short,
        h: ::std::os::raw::c_short,
        b: *const TScreenCell,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN5TView9writeLineEssssPK11TScreenCell"]
    pub fn TView_writeLine2(
        this: *mut TView,
        x: ::std::os::raw::c_short,
        y: ::std::os::raw::c_short,
        w: ::std::os::raw::c_short,
        h: ::std::os::raw::c_short,
        b: *const TScreenCell,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN5TView5buildEv"]
    pub fn TView_build() -> *mut TStreamable;
}
extern "C" {
    #[link_name = "\u{1}_ZN5TViewC1ERK5TRect"]
    pub fn TView_TView(this: *mut TView, bounds: *const TRect);
}
extern "C" {
    #[link_name = "\u{1}_ZN5TViewC1E14StreamableInit"]
    pub fn TView_TView1(this: *mut TView, arg1: StreamableInit);
}
impl TView {
    #[inline]
    pub unsafe fn getBounds(&self) -> TRect {
        TView_getBounds(self)
    }
    #[inline]
    pub unsafe fn getExtent(&self) -> TRect {
        TView_getExtent(self)
    }
    #[inline]
    pub unsafe fn getClipRect(&self) -> TRect {
        TView_getClipRect(self)
    }
    #[inline]
    pub unsafe fn mouseInView(&mut self, mouse: TPoint) -> Boolean {
        TView_mouseInView(self, mouse)
    }
    #[inline]
    pub unsafe fn containsMouse(&mut self, event: *mut TEvent) -> Boolean {
        TView_containsMouse(self, event)
    }
    #[inline]
    pub unsafe fn locate(&mut self, bounds: *mut TRect) {
        TView_locate(self, bounds)
    }
    #[inline]
    pub unsafe fn growTo(&mut self, x: ::std::os::raw::c_short, y: ::std::os::raw::c_short) {
        TView_growTo(self, x, y)
    }
    #[inline]
    pub unsafe fn moveTo(&mut self, x: ::std::os::raw::c_short, y: ::std::os::raw::c_short) {
        TView_moveTo(self, x, y)
    }
    #[inline]
    pub unsafe fn setBounds(&mut self, bounds: *const TRect) {
        TView_setBounds(self, bounds)
    }
    #[inline]
    pub unsafe fn hide(&mut self) {
        TView_hide(self)
    }
    #[inline]
    pub unsafe fn show(&mut self) {
        TView_show(self)
    }
    #[inline]
    pub unsafe fn drawView(&mut self) {
        TView_drawView(self)
    }
    #[inline]
    pub unsafe fn exposed(&mut self) -> Boolean {
        TView_exposed(self)
    }
    #[inline]
    pub unsafe fn focus(&mut self) -> Boolean {
        TView_focus(self)
    }
    #[inline]
    pub unsafe fn hideCursor(&mut self) {
        TView_hideCursor(self)
    }
    #[inline]
    pub unsafe fn drawHide(&mut self, lastView: *mut TView) {
        TView_drawHide(self, lastView)
    }
    #[inline]
    pub unsafe fn drawShow(&mut self, lastView: *mut TView) {
        TView_drawShow(self, lastView)
    }
    #[inline]
    pub unsafe fn drawUnderRect(&mut self, r: *mut TRect, lastView: *mut TView) {
        TView_drawUnderRect(self, r, lastView)
    }
    #[inline]
    pub unsafe fn drawUnderView(&mut self, doShadow: Boolean, lastView: *mut TView) {
        TView_drawUnderView(self, doShadow, lastView)
    }
    #[inline]
    pub unsafe fn blockCursor(&mut self) {
        TView_blockCursor(self)
    }
    #[inline]
    pub unsafe fn normalCursor(&mut self) {
        TView_normalCursor(self)
    }
    #[inline]
    pub unsafe fn setCursor(&mut self, x: ::std::os::raw::c_int, y: ::std::os::raw::c_int) {
        TView_setCursor(self, x, y)
    }
    #[inline]
    pub unsafe fn showCursor(&mut self) {
        TView_showCursor(self)
    }
    #[inline]
    pub unsafe fn drawCursor(&mut self) {
        TView_drawCursor(self)
    }
    #[inline]
    pub unsafe fn clearEvent(&mut self, event: *mut TEvent) {
        TView_clearEvent(self, event)
    }
    #[inline]
    pub unsafe fn eventAvail(&mut self) -> Boolean {
        TView_eventAvail(self)
    }
    #[inline]
    pub unsafe fn commandEnabled(command: ushort) -> Boolean {
        TView_commandEnabled(command)
    }
    #[inline]
    pub unsafe fn disableCommands(commands: *mut TCommandSet) {
        TView_disableCommands(commands)
    }
    #[inline]
    pub unsafe fn enableCommands(commands: *mut TCommandSet) {
        TView_enableCommands(commands)
    }
    #[inline]
    pub unsafe fn disableCommand(command: ushort) {
        TView_disableCommand(command)
    }
    #[inline]
    pub unsafe fn enableCommand(command: ushort) {
        TView_enableCommand(command)
    }
    #[inline]
    pub unsafe fn getCommands(commands: *mut TCommandSet) {
        TView_getCommands(commands)
    }
    #[inline]
    pub unsafe fn setCommands(commands: *mut TCommandSet) {
        TView_setCommands(commands)
    }
    #[inline]
    pub unsafe fn setCmdState(commands: *mut TCommandSet, enable: Boolean) {
        TView_setCmdState(commands, enable)
    }
    #[inline]
    pub unsafe fn getColor(&mut self, color: ushort) -> ushort {
        TView_getColor(self, color)
    }
    #[inline]
    pub unsafe fn mapColor(&mut self, arg1: uchar) -> uchar {
        TView_mapColor(self, arg1)
    }
    #[inline]
    pub unsafe fn getState(&self, aState: ushort) -> Boolean {
        TView_getState(self, aState)
    }
    #[inline]
    pub unsafe fn select(&mut self) {
        TView_select(self)
    }
    #[inline]
    pub unsafe fn keyEvent(&mut self, event: *mut TEvent) {
        TView_keyEvent(self, event)
    }
    #[inline]
    pub unsafe fn mouseEvent(&mut self, event: *mut TEvent, mask: ushort) -> Boolean {
        TView_mouseEvent(self, event, mask)
    }
    #[inline]
    pub unsafe fn textEvent(
        &mut self,
        event: *mut TEvent,
        dest: TSpan<::std::os::raw::c_char>,
        length: *mut size_t,
    ) -> Boolean {
        TView_textEvent1(self, event, dest, length)
    }
    #[inline]
    pub unsafe fn makeGlobal(&mut self, source: TPoint) -> TPoint {
        TView_makeGlobal(self, source)
    }
    #[inline]
    pub unsafe fn makeLocal(&mut self, source: TPoint) -> TPoint {
        TView_makeLocal(self, source)
    }
    #[inline]
    pub unsafe fn nextView(&mut self) -> *mut TView {
        TView_nextView(self)
    }
    #[inline]
    pub unsafe fn prevView(&mut self) -> *mut TView {
        TView_prevView(self)
    }
    #[inline]
    pub unsafe fn prev(&mut self) -> *mut TView {
        TView_prev(self)
    }
    #[inline]
    pub unsafe fn makeFirst(&mut self) {
        TView_makeFirst(self)
    }
    #[inline]
    pub unsafe fn putInFrontOf(&mut self, Target: *mut TView) {
        TView_putInFrontOf(self, Target)
    }
    #[inline]
    pub unsafe fn TopView(&mut self) -> *mut TView {
        TView_TopView(self)
    }
    #[inline]
    pub unsafe fn writeBuf(
        &mut self,
        x: ::std::os::raw::c_short,
        y: ::std::os::raw::c_short,
        w: ::std::os::raw::c_short,
        h: ::std::os::raw::c_short,
        b: *const ::std::os::raw::c_void,
    ) {
        TView_writeBuf(self, x, y, w, h, b)
    }
    #[inline]
    pub unsafe fn writeBuf1(
        &mut self,
        x: ::std::os::raw::c_short,
        y: ::std::os::raw::c_short,
        w: ::std::os::raw::c_short,
        h: ::std::os::raw::c_short,
        b: *const TDrawBuffer,
    ) {
        TView_writeBuf1(self, x, y, w, h, b)
    }
    #[inline]
    pub unsafe fn writeChar(
        &mut self,
        x: ::std::os::raw::c_short,
        y: ::std::os::raw::c_short,
        c: ::std::os::raw::c_char,
        color: uchar,
        count: ::std::os::raw::c_short,
    ) {
        TView_writeChar(self, x, y, c, color, count)
    }
    #[inline]
    pub unsafe fn writeLine(
        &mut self,
        x: ::std::os::raw::c_short,
        y: ::std::os::raw::c_short,
        w: ::std::os::raw::c_short,
        h: ::std::os::raw::c_short,
        b: *const TDrawBuffer,
    ) {
        TView_writeLine(self, x, y, w, h, b)
    }
    #[inline]
    pub unsafe fn writeLine1(
        &mut self,
        x: ::std::os::raw::c_short,
        y: ::std::os::raw::c_short,
        w: ::std::os::raw::c_short,
        h: ::std::os::raw::c_short,
        b: *const ::std::os::raw::c_void,
    ) {
        TView_writeLine1(self, x, y, w, h, b)
    }
    #[inline]
    pub unsafe fn writeStr(
        &mut self,
        x: ::std::os::raw::c_short,
        y: ::std::os::raw::c_short,
        str_: *const ::std::os::raw::c_char,
        color: uchar,
    ) {
        TView_writeStr(self, x, y, str_, color)
    }
    #[inline]
    pub unsafe fn writeBuf2(
        &mut self,
        x: ::std::os::raw::c_short,
        y: ::std::os::raw::c_short,
        w: ::std::os::raw::c_short,
        h: ::std::os::raw::c_short,
        b: *const TScreenCell,
    ) {
        TView_writeBuf2(self, x, y, w, h, b)
    }
    #[inline]
    pub unsafe fn writeLine2(
        &mut self,
        x: ::std::os::raw::c_short,
        y: ::std::os::raw::c_short,
        w: ::std::os::raw::c_short,
        h: ::std::os::raw::c_short,
        b: *const TScreenCell,
    ) {
        TView_writeLine2(self, x, y, w, h, b)
    }
    #[inline]
    pub unsafe fn build() -> *mut TStreamable {
        TView_build()
    }
    #[inline]
    pub unsafe fn new(bounds: *const TRect) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        TView_TView(__bindgen_tmp.as_mut_ptr(), bounds);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(arg1: StreamableInit) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        TView_TView1(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN5TViewD1Ev"]
    pub fn TView_TView_destructor(this: *mut TView);
}
extern "C" {
    #[link_name = "\u{1}_ZN5TView10sizeLimitsER6TPointS1_"]
    pub fn TView_sizeLimits(this: *mut ::std::os::raw::c_void, min: *mut TPoint, max: *mut TPoint);
}
extern "C" {
    #[link_name = "\u{1}_ZN5TView8dragViewER6TEventhR5TRect6TPointS4_"]
    pub fn TView_dragView(
        this: *mut ::std::os::raw::c_void,
        event: *mut TEvent,
        mode: uchar,
        limits: *mut TRect,
        minSize: TPoint,
        maxSize: TPoint,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN5TView10calcBoundsER5TRect6TPoint"]
    pub fn TView_calcBounds(this: *mut ::std::os::raw::c_void, bounds: *mut TRect, delta: TPoint);
}
extern "C" {
    #[link_name = "\u{1}_ZN5TView12changeBoundsERK5TRect"]
    pub fn TView_changeBounds(this: *mut ::std::os::raw::c_void, bounds: *const TRect);
}
extern "C" {
    #[link_name = "\u{1}_ZN5TView10getHelpCtxEv"]
    pub fn TView_getHelpCtx(this: *mut ::std::os::raw::c_void) -> ushort;
}
extern "C" {
    #[link_name = "\u{1}_ZN5TView5validEt"]
    pub fn TView_valid(this: *mut ::std::os::raw::c_void, command: ushort) -> Boolean;
}
extern "C" {
    #[link_name = "\u{1}_ZN5TView4drawEv"]
    pub fn TView_draw(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[link_name = "\u{1}_ZN5TView8dataSizeEv"]
    pub fn TView_dataSize(this: *mut ::std::os::raw::c_void) -> ushort;
}
extern "C" {
    #[link_name = "\u{1}_ZN5TView7getDataEPv"]
    pub fn TView_getData(this: *mut ::std::os::raw::c_void, rec: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[link_name = "\u{1}_ZN5TView7setDataEPv"]
    pub fn TView_setData(this: *mut ::std::os::raw::c_void, rec: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[link_name = "\u{1}_ZN5TView6awakenEv"]
    pub fn TView_awaken(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[link_name = "\u{1}_ZN5TView11resetCursorEv"]
    pub fn TView_resetCursor(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[link_name = "\u{1}_ZN5TView8getEventER6TEvent"]
    pub fn TView_getEvent(this: *mut ::std::os::raw::c_void, event: *mut TEvent);
}
extern "C" {
    #[link_name = "\u{1}_ZN5TView11handleEventER6TEvent"]
    pub fn TView_handleEvent(this: *mut ::std::os::raw::c_void, event: *mut TEvent);
}
extern "C" {
    #[link_name = "\u{1}_ZN5TView8putEventER6TEvent"]
    pub fn TView_putEvent(this: *mut ::std::os::raw::c_void, event: *mut TEvent);
}
extern "C" {
    #[link_name = "\u{1}_ZN5TView8endModalEt"]
    pub fn TView_endModal(this: *mut ::std::os::raw::c_void, command: ushort);
}
extern "C" {
    #[link_name = "\u{1}_ZN5TView7executeEv"]
    pub fn TView_execute(this: *mut ::std::os::raw::c_void) -> ushort;
}
extern "C" {
    #[link_name = "\u{1}_ZNK5TView10getPaletteEv"]
    pub fn TView_getPalette(this: *mut ::std::os::raw::c_void) -> *mut TPalette;
}
extern "C" {
    #[link_name = "\u{1}_ZN5TView8setStateEtb"]
    pub fn TView_setState(this: *mut ::std::os::raw::c_void, aState: ushort, enable: Boolean);
}
extern "C" {
    #[link_name = "\u{1}_ZN5TView9textEventER6TEvent5TSpanIcERmS4_"]
    pub fn TView_textEvent(
        this: *mut ::std::os::raw::c_void,
        event: *mut TEvent,
        dest: TSpan<::std::os::raw::c_char>,
        length: *mut size_t,
        count: *mut size_t,
    ) -> Boolean;
}
extern "C" {
    #[link_name = "\u{1}_ZN5TView8shutDownEv"]
    pub fn TView_shutDown(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[link_name = "\u{1}_ZThn8_N5TView5writeER8opstream"]
    pub fn TView_write(this: *mut ::std::os::raw::c_void, arg1: *mut opstream);
}
extern "C" {
    #[link_name = "\u{1}_ZThn8_N5TView4readER8ipstream"]
    pub fn TView_read(
        this: *mut ::std::os::raw::c_void,
        arg1: *mut ipstream,
    ) -> *mut ::std::os::raw::c_void;
}
#[repr(C)]
#[derive(Debug)]
pub struct TGroup {
    pub _base: TView,
    pub current: *mut TView,
    pub last: *mut TView,
    pub clip: TRect,
    pub phase: TView_phaseType,
    pub buffer: *mut TScreenCell,
    pub lockFlag: uchar,
    pub endState: ushort,
}
extern "C" {
    #[link_name = "\u{1}_ZN6TGroup4nameE"]
    pub static TGroup_name: *const ::std::os::raw::c_char;
}
#[test]
fn bindgen_test_layout_TGroup() {
    assert_eq!(
        ::std::mem::size_of::<TGroup>(),
        136usize,
        concat!("Size of: ", stringify!(TGroup))
    );
    assert_eq!(
        ::std::mem::align_of::<TGroup>(),
        8usize,
        concat!("Alignment of ", stringify!(TGroup))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TGroup>())).current as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(TGroup),
            "::",
            stringify!(current)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TGroup>())).last as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(TGroup),
            "::",
            stringify!(last)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TGroup>())).clip as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(TGroup),
            "::",
            stringify!(clip)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TGroup>())).phase as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(TGroup),
            "::",
            stringify!(phase)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TGroup>())).buffer as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(TGroup),
            "::",
            stringify!(buffer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TGroup>())).lockFlag as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(TGroup),
            "::",
            stringify!(lockFlag)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TGroup>())).endState as *const _ as usize },
        130usize,
        concat!(
            "Offset of field: ",
            stringify!(TGroup),
            "::",
            stringify!(endState)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN6TGroup8execViewEP5TView"]
    pub fn TGroup_execView(this: *mut TGroup, p: *mut TView) -> ushort;
}
extern "C" {
    #[link_name = "\u{1}_ZN6TGroup10insertViewEP5TViewS1_"]
    pub fn TGroup_insertView(this: *mut TGroup, p: *mut TView, Target: *mut TView);
}
extern "C" {
    #[link_name = "\u{1}_ZN6TGroup6removeEP5TView"]
    pub fn TGroup_remove(this: *mut TGroup, p: *mut TView);
}
extern "C" {
    #[link_name = "\u{1}_ZN6TGroup10removeViewEP5TView"]
    pub fn TGroup_removeView(this: *mut TGroup, p: *mut TView);
}
extern "C" {
    #[link_name = "\u{1}_ZN6TGroup12resetCurrentEv"]
    pub fn TGroup_resetCurrent(this: *mut TGroup);
}
extern "C" {
    #[link_name = "\u{1}_ZN6TGroup10setCurrentEP5TViewNS0_10selectModeE"]
    pub fn TGroup_setCurrent(this: *mut TGroup, p: *mut TView, mode: TView_selectMode);
}
extern "C" {
    #[link_name = "\u{1}_ZN6TGroup10selectNextEb"]
    pub fn TGroup_selectNext(this: *mut TGroup, forwards: Boolean);
}
extern "C" {
    #[link_name = "\u{1}_ZN6TGroup9firstThatEPFbP5TViewPvES2_"]
    pub fn TGroup_firstThat(
        this: *mut TGroup,
        func: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut TView, arg2: *mut ::std::os::raw::c_void) -> Boolean,
        >,
        args: *mut ::std::os::raw::c_void,
    ) -> *mut TView;
}
extern "C" {
    #[link_name = "\u{1}_ZN6TGroup9focusNextEb"]
    pub fn TGroup_focusNext(this: *mut TGroup, forwards: Boolean) -> Boolean;
}
extern "C" {
    #[link_name = "\u{1}_ZN6TGroup7forEachEPFvP5TViewPvES2_"]
    pub fn TGroup_forEach(
        this: *mut TGroup,
        func: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut TView, arg2: *mut ::std::os::raw::c_void),
        >,
        args: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN6TGroup6insertEP5TView"]
    pub fn TGroup_insert(this: *mut TGroup, p: *mut TView);
}
extern "C" {
    #[link_name = "\u{1}_ZN6TGroup12insertBeforeEP5TViewS1_"]
    pub fn TGroup_insertBefore(this: *mut TGroup, p: *mut TView, Target: *mut TView);
}
extern "C" {
    #[link_name = "\u{1}_ZN6TGroup2atEs"]
    pub fn TGroup_at(this: *mut TGroup, index: ::std::os::raw::c_short) -> *mut TView;
}
extern "C" {
    #[link_name = "\u{1}_ZN6TGroup10firstMatchEtt"]
    pub fn TGroup_firstMatch(this: *mut TGroup, aState: ushort, aOptions: ushort) -> *mut TView;
}
extern "C" {
    #[link_name = "\u{1}_ZN6TGroup7indexOfEP5TView"]
    pub fn TGroup_indexOf(this: *mut TGroup, p: *mut TView) -> ::std::os::raw::c_short;
}
extern "C" {
    #[link_name = "\u{1}_ZN6TGroup7matchesEP5TView"]
    pub fn TGroup_matches(this: *mut TGroup, p: *mut TView) -> Boolean;
}
extern "C" {
    #[link_name = "\u{1}_ZN6TGroup5firstEv"]
    pub fn TGroup_first(this: *mut TGroup) -> *mut TView;
}
extern "C" {
    #[link_name = "\u{1}_ZN6TGroup12drawSubViewsEP5TViewS1_"]
    pub fn TGroup_drawSubViews(this: *mut TGroup, p: *mut TView, bottom: *mut TView);
}
extern "C" {
    #[link_name = "\u{1}_ZN6TGroup6redrawEv"]
    pub fn TGroup_redraw(this: *mut TGroup);
}
extern "C" {
    #[link_name = "\u{1}_ZN6TGroup4lockEv"]
    pub fn TGroup_lock(this: *mut TGroup);
}
extern "C" {
    #[link_name = "\u{1}_ZN6TGroup6unlockEv"]
    pub fn TGroup_unlock(this: *mut TGroup);
}
extern "C" {
    #[link_name = "\u{1}_ZN6TGroup10freeBufferEv"]
    pub fn TGroup_freeBuffer(this: *mut TGroup);
}
extern "C" {
    #[link_name = "\u{1}_ZN6TGroup9getBufferEv"]
    pub fn TGroup_getBuffer(this: *mut TGroup);
}
extern "C" {
    #[link_name = "\u{1}_ZN6TGroup5buildEv"]
    pub fn TGroup_build() -> *mut TStreamable;
}
extern "C" {
    #[link_name = "\u{1}_ZN6TGroupC1ERK5TRect"]
    pub fn TGroup_TGroup(this: *mut TGroup, bounds: *const TRect);
}
extern "C" {
    #[link_name = "\u{1}_ZN6TGroupC1E14StreamableInit"]
    pub fn TGroup_TGroup1(this: *mut TGroup, arg1: StreamableInit);
}
impl TGroup {
    #[inline]
    pub unsafe fn execView(&mut self, p: *mut TView) -> ushort {
        TGroup_execView(self, p)
    }
    #[inline]
    pub unsafe fn insertView(&mut self, p: *mut TView, Target: *mut TView) {
        TGroup_insertView(self, p, Target)
    }
    #[inline]
    pub unsafe fn remove(&mut self, p: *mut TView) {
        TGroup_remove(self, p)
    }
    #[inline]
    pub unsafe fn removeView(&mut self, p: *mut TView) {
        TGroup_removeView(self, p)
    }
    #[inline]
    pub unsafe fn resetCurrent(&mut self) {
        TGroup_resetCurrent(self)
    }
    #[inline]
    pub unsafe fn setCurrent(&mut self, p: *mut TView, mode: TView_selectMode) {
        TGroup_setCurrent(self, p, mode)
    }
    #[inline]
    pub unsafe fn selectNext(&mut self, forwards: Boolean) {
        TGroup_selectNext(self, forwards)
    }
    #[inline]
    pub unsafe fn firstThat(
        &mut self,
        func: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut TView, arg2: *mut ::std::os::raw::c_void) -> Boolean,
        >,
        args: *mut ::std::os::raw::c_void,
    ) -> *mut TView {
        TGroup_firstThat(self, func, args)
    }
    #[inline]
    pub unsafe fn focusNext(&mut self, forwards: Boolean) -> Boolean {
        TGroup_focusNext(self, forwards)
    }
    #[inline]
    pub unsafe fn forEach(
        &mut self,
        func: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut TView, arg2: *mut ::std::os::raw::c_void),
        >,
        args: *mut ::std::os::raw::c_void,
    ) {
        TGroup_forEach(self, func, args)
    }
    #[inline]
    pub unsafe fn insert(&mut self, p: *mut TView) {
        TGroup_insert(self, p)
    }
    #[inline]
    pub unsafe fn insertBefore(&mut self, p: *mut TView, Target: *mut TView) {
        TGroup_insertBefore(self, p, Target)
    }
    #[inline]
    pub unsafe fn at(&mut self, index: ::std::os::raw::c_short) -> *mut TView {
        TGroup_at(self, index)
    }
    #[inline]
    pub unsafe fn firstMatch(&mut self, aState: ushort, aOptions: ushort) -> *mut TView {
        TGroup_firstMatch(self, aState, aOptions)
    }
    #[inline]
    pub unsafe fn indexOf(&mut self, p: *mut TView) -> ::std::os::raw::c_short {
        TGroup_indexOf(self, p)
    }
    #[inline]
    pub unsafe fn matches(&mut self, p: *mut TView) -> Boolean {
        TGroup_matches(self, p)
    }
    #[inline]
    pub unsafe fn first(&mut self) -> *mut TView {
        TGroup_first(self)
    }
    #[inline]
    pub unsafe fn drawSubViews(&mut self, p: *mut TView, bottom: *mut TView) {
        TGroup_drawSubViews(self, p, bottom)
    }
    #[inline]
    pub unsafe fn redraw(&mut self) {
        TGroup_redraw(self)
    }
    #[inline]
    pub unsafe fn lock(&mut self) {
        TGroup_lock(self)
    }
    #[inline]
    pub unsafe fn unlock(&mut self) {
        TGroup_unlock(self)
    }
    #[inline]
    pub unsafe fn freeBuffer(&mut self) {
        TGroup_freeBuffer(self)
    }
    #[inline]
    pub unsafe fn getBuffer(&mut self) {
        TGroup_getBuffer(self)
    }
    #[inline]
    pub unsafe fn build() -> *mut TStreamable {
        TGroup_build()
    }
    #[inline]
    pub unsafe fn new(bounds: *const TRect) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        TGroup_TGroup(__bindgen_tmp.as_mut_ptr(), bounds);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(arg1: StreamableInit) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        TGroup_TGroup1(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN6TGroupD1Ev"]
    pub fn TGroup_TGroup_destructor(this: *mut TGroup);
}
extern "C" {
    #[link_name = "\u{1}_ZN6TGroup8shutDownEv"]
    pub fn TGroup_shutDown(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[link_name = "\u{1}_ZN6TGroup7executeEv"]
    pub fn TGroup_execute(this: *mut ::std::os::raw::c_void) -> ushort;
}
extern "C" {
    #[link_name = "\u{1}_ZN6TGroup6awakenEv"]
    pub fn TGroup_awaken(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[link_name = "\u{1}_ZN6TGroup8setStateEtb"]
    pub fn TGroup_setState(this: *mut ::std::os::raw::c_void, aState: ushort, enable: Boolean);
}
extern "C" {
    #[link_name = "\u{1}_ZN6TGroup11handleEventER6TEvent"]
    pub fn TGroup_handleEvent(this: *mut ::std::os::raw::c_void, event: *mut TEvent);
}
extern "C" {
    #[link_name = "\u{1}_ZN6TGroup12changeBoundsERK5TRect"]
    pub fn TGroup_changeBounds(this: *mut ::std::os::raw::c_void, bounds: *const TRect);
}
extern "C" {
    #[link_name = "\u{1}_ZN6TGroup8dataSizeEv"]
    pub fn TGroup_dataSize(this: *mut ::std::os::raw::c_void) -> ushort;
}
extern "C" {
    #[link_name = "\u{1}_ZN6TGroup7getDataEPv"]
    pub fn TGroup_getData(this: *mut ::std::os::raw::c_void, rec: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[link_name = "\u{1}_ZN6TGroup7setDataEPv"]
    pub fn TGroup_setData(this: *mut ::std::os::raw::c_void, rec: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[link_name = "\u{1}_ZN6TGroup4drawEv"]
    pub fn TGroup_draw(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[link_name = "\u{1}_ZN6TGroup11resetCursorEv"]
    pub fn TGroup_resetCursor(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[link_name = "\u{1}_ZN6TGroup8endModalEt"]
    pub fn TGroup_endModal(this: *mut ::std::os::raw::c_void, command: ushort);
}
extern "C" {
    #[link_name = "\u{1}_ZN6TGroup10eventErrorER6TEvent"]
    pub fn TGroup_eventError(this: *mut ::std::os::raw::c_void, event: *mut TEvent);
}
extern "C" {
    #[link_name = "\u{1}_ZN6TGroup10getHelpCtxEv"]
    pub fn TGroup_getHelpCtx(this: *mut ::std::os::raw::c_void) -> ushort;
}
extern "C" {
    #[link_name = "\u{1}_ZN6TGroup5validEt"]
    pub fn TGroup_valid(this: *mut ::std::os::raw::c_void, command: ushort) -> Boolean;
}
extern "C" {
    #[link_name = "\u{1}_ZThn8_N6TGroup5writeER8opstream"]
    pub fn TGroup_write(this: *mut ::std::os::raw::c_void, arg1: *mut opstream);
}
extern "C" {
    #[link_name = "\u{1}_ZThn8_N6TGroup4readER8ipstream"]
    pub fn TGroup_read(
        this: *mut ::std::os::raw::c_void,
        arg1: *mut ipstream,
    ) -> *mut ::std::os::raw::c_void;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TFrame {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TScrollBar {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TWindowInit {
    pub createFrame: ::std::option::Option<unsafe extern "C" fn(arg1: TRect) -> *mut TFrame>,
}
#[test]
fn bindgen_test_layout_TWindowInit() {
    assert_eq!(
        ::std::mem::size_of::<TWindowInit>(),
        8usize,
        concat!("Size of: ", stringify!(TWindowInit))
    );
    assert_eq!(
        ::std::mem::align_of::<TWindowInit>(),
        8usize,
        concat!("Alignment of ", stringify!(TWindowInit))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TWindowInit>())).createFrame as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TWindowInit),
            "::",
            stringify!(createFrame)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN11TWindowInitC1EPFP6TFrame5TRectE"]
    pub fn TWindowInit_TWindowInit(
        this: *mut TWindowInit,
        cFrame: ::std::option::Option<unsafe extern "C" fn(arg1: TRect) -> *mut TFrame>,
    );
}
impl TWindowInit {
    #[inline]
    pub unsafe fn new(
        cFrame: ::std::option::Option<unsafe extern "C" fn(arg1: TRect) -> *mut TFrame>,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        TWindowInit_TWindowInit(__bindgen_tmp.as_mut_ptr(), cFrame);
        __bindgen_tmp.assume_init()
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct TWindow {
    pub _base: TGroup,
    pub flags: uchar,
    pub zoomRect: TRect,
    pub number: ::std::os::raw::c_short,
    pub palette: ::std::os::raw::c_short,
    pub frame: *mut TFrame,
    pub title: *const ::std::os::raw::c_char,
    pub __bindgen_padding_0: u64,
}
extern "C" {
    #[link_name = "\u{1}_ZN7TWindow4nameE"]
    pub static TWindow_name: *const ::std::os::raw::c_char;
}
#[test]
fn bindgen_test_layout_TWindow() {
    assert_eq!(
        ::std::mem::size_of::<TWindow>(),
        184usize,
        concat!("Size of: ", stringify!(TWindow))
    );
    assert_eq!(
        ::std::mem::align_of::<TWindow>(),
        8usize,
        concat!("Alignment of ", stringify!(TWindow))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TWindow>())).flags as *const _ as usize },
        132usize,
        concat!(
            "Offset of field: ",
            stringify!(TWindow),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TWindow>())).zoomRect as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(TWindow),
            "::",
            stringify!(zoomRect)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TWindow>())).number as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(TWindow),
            "::",
            stringify!(number)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TWindow>())).palette as *const _ as usize },
        154usize,
        concat!(
            "Offset of field: ",
            stringify!(TWindow),
            "::",
            stringify!(palette)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TWindow>())).frame as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(TWindow),
            "::",
            stringify!(frame)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TWindow>())).title as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(TWindow),
            "::",
            stringify!(title)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN7TWindow9initFrameE5TRect"]
    pub fn TWindow_initFrame(arg1: TRect) -> *mut TFrame;
}
extern "C" {
    #[link_name = "\u{1}_ZN7TWindow17standardScrollBarEt"]
    pub fn TWindow_standardScrollBar(this: *mut TWindow, aOptions: ushort) -> *mut TScrollBar;
}
extern "C" {
    #[link_name = "\u{1}_ZN7TWindow5buildEv"]
    pub fn TWindow_build() -> *mut TStreamable;
}
extern "C" {
    #[link_name = "\u{1}_ZN7TWindowC1ERK5TRect11TStringViews"]
    pub fn TWindow_TWindow(
        this: *mut TWindow,
        bounds: *const TRect,
        aTitle: TStringView,
        aNumber: ::std::os::raw::c_short,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN7TWindowC1E14StreamableInit"]
    pub fn TWindow_TWindow1(this: *mut TWindow, arg1: StreamableInit);
}
impl TWindow {
    #[inline]
    pub unsafe fn initFrame(arg1: TRect) -> *mut TFrame {
        TWindow_initFrame(arg1)
    }
    #[inline]
    pub unsafe fn standardScrollBar(&mut self, aOptions: ushort) -> *mut TScrollBar {
        TWindow_standardScrollBar(self, aOptions)
    }
    #[inline]
    pub unsafe fn build() -> *mut TStreamable {
        TWindow_build()
    }
    #[inline]
    pub unsafe fn new(
        bounds: *const TRect,
        aTitle: TStringView,
        aNumber: ::std::os::raw::c_short,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        TWindow_TWindow(__bindgen_tmp.as_mut_ptr(), bounds, aTitle, aNumber);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(arg1: StreamableInit) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        TWindow_TWindow1(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN7TWindowD1Ev"]
    pub fn TWindow_TWindow_destructor(this: *mut TWindow);
}
extern "C" {
    #[link_name = "\u{1}_ZN7TWindow5closeEv"]
    pub fn TWindow_close(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[link_name = "\u{1}_ZNK7TWindow10getPaletteEv"]
    pub fn TWindow_getPalette(this: *mut ::std::os::raw::c_void) -> *mut TPalette;
}
extern "C" {
    #[link_name = "\u{1}_ZN7TWindow8getTitleEs"]
    pub fn TWindow_getTitle(
        this: *mut ::std::os::raw::c_void,
        maxSize: ::std::os::raw::c_short,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_ZN7TWindow11handleEventER6TEvent"]
    pub fn TWindow_handleEvent(this: *mut ::std::os::raw::c_void, event: *mut TEvent);
}
extern "C" {
    #[link_name = "\u{1}_ZN7TWindow8setStateEtb"]
    pub fn TWindow_setState(this: *mut ::std::os::raw::c_void, aState: ushort, enable: Boolean);
}
extern "C" {
    #[link_name = "\u{1}_ZN7TWindow10sizeLimitsER6TPointS1_"]
    pub fn TWindow_sizeLimits(
        this: *mut ::std::os::raw::c_void,
        min: *mut TPoint,
        max: *mut TPoint,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN7TWindow4zoomEv"]
    pub fn TWindow_zoom(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[link_name = "\u{1}_ZN7TWindow8shutDownEv"]
    pub fn TWindow_shutDown(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[link_name = "\u{1}_ZThn8_N7TWindow5writeER8opstream"]
    pub fn TWindow_write(this: *mut ::std::os::raw::c_void, arg1: *mut opstream);
}
extern "C" {
    #[link_name = "\u{1}_ZThn8_N7TWindow4readER8ipstream"]
    pub fn TWindow_read(
        this: *mut ::std::os::raw::c_void,
        arg1: *mut ipstream,
    ) -> *mut ::std::os::raw::c_void;
}
#[repr(C)]
#[derive(Debug)]
pub struct TDialog {
    pub _base: TWindow,
}
extern "C" {
    #[link_name = "\u{1}_ZN7TDialog4nameE"]
    pub static TDialog_name: *const ::std::os::raw::c_char;
}
#[test]
fn bindgen_test_layout_TDialog() {
    assert_eq!(
        ::std::mem::size_of::<TDialog>(),
        184usize,
        concat!("Size of: ", stringify!(TDialog))
    );
    assert_eq!(
        ::std::mem::align_of::<TDialog>(),
        8usize,
        concat!("Alignment of ", stringify!(TDialog))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN7TDialog5buildEv"]
    pub fn TDialog_build() -> *mut TStreamable;
}
extern "C" {
    #[link_name = "\u{1}_ZN7TDialogC1ERK5TRect11TStringView"]
    pub fn TDialog_TDialog(this: *mut TDialog, bounds: *const TRect, aTitle: TStringView);
}
extern "C" {
    #[link_name = "\u{1}_ZN7TDialogC1E14StreamableInit"]
    pub fn TDialog_TDialog1(this: *mut TDialog, arg1: StreamableInit);
}
impl TDialog {
    #[inline]
    pub unsafe fn build() -> *mut TStreamable {
        TDialog_build()
    }
    #[inline]
    pub unsafe fn new(bounds: *const TRect, aTitle: TStringView) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        TDialog_TDialog(__bindgen_tmp.as_mut_ptr(), bounds, aTitle);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(arg1: StreamableInit) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        TDialog_TDialog1(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}_ZNK7TDialog10getPaletteEv"]
    pub fn TDialog_getPalette(this: *mut ::std::os::raw::c_void) -> *mut TPalette;
}
extern "C" {
    #[link_name = "\u{1}_ZN7TDialog11handleEventER6TEvent"]
    pub fn TDialog_handleEvent(this: *mut ::std::os::raw::c_void, event: *mut TEvent);
}
extern "C" {
    #[link_name = "\u{1}_ZN7TDialog5validEt"]
    pub fn TDialog_valid(this: *mut ::std::os::raw::c_void, command: ushort) -> Boolean;
}
#[repr(C)]
pub struct TMenuItem {
    pub next: *mut TMenuItem,
    pub name: *const ::std::os::raw::c_char,
    pub command: ushort,
    pub disabled: Boolean,
    pub keyCode: ushort,
    pub helpCtx: ushort,
    pub __bindgen_anon_1: TMenuItem__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union TMenuItem__bindgen_ty_1 {
    pub param: *const ::std::os::raw::c_char,
    pub subMenu: *mut TMenu,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_TMenuItem__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<TMenuItem__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(TMenuItem__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<TMenuItem__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(TMenuItem__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TMenuItem__bindgen_ty_1>())).param as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TMenuItem__bindgen_ty_1),
            "::",
            stringify!(param)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TMenuItem__bindgen_ty_1>())).subMenu as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TMenuItem__bindgen_ty_1),
            "::",
            stringify!(subMenu)
        )
    );
}
#[test]
fn bindgen_test_layout_TMenuItem() {
    assert_eq!(
        ::std::mem::size_of::<TMenuItem>(),
        32usize,
        concat!("Size of: ", stringify!(TMenuItem))
    );
    assert_eq!(
        ::std::mem::align_of::<TMenuItem>(),
        8usize,
        concat!("Alignment of ", stringify!(TMenuItem))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TMenuItem>())).next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TMenuItem),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TMenuItem>())).name as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(TMenuItem),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TMenuItem>())).command as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(TMenuItem),
            "::",
            stringify!(command)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TMenuItem>())).disabled as *const _ as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(TMenuItem),
            "::",
            stringify!(disabled)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TMenuItem>())).keyCode as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(TMenuItem),
            "::",
            stringify!(keyCode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TMenuItem>())).helpCtx as *const _ as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(TMenuItem),
            "::",
            stringify!(helpCtx)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN9TMenuItem6appendEPS_"]
    pub fn TMenuItem_append(this: *mut TMenuItem, aNext: *mut TMenuItem);
}
extern "C" {
    #[link_name = "\u{1}_ZN9TMenuItemC1E11TStringViewtttS0_PS_"]
    pub fn TMenuItem_TMenuItem(
        this: *mut TMenuItem,
        aName: TStringView,
        aCommand: ushort,
        aKeyCode: ushort,
        aHelpCtx: ushort,
        p: TStringView,
        aNext: *mut TMenuItem,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN9TMenuItemC1E11TStringViewtP5TMenutPS_"]
    pub fn TMenuItem_TMenuItem1(
        this: *mut TMenuItem,
        aName: TStringView,
        aKeyCode: ushort,
        aSubMenu: *mut TMenu,
        aHelpCtx: ushort,
        aNext: *mut TMenuItem,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN9TMenuItemD1Ev"]
    pub fn TMenuItem_TMenuItem_destructor(this: *mut TMenuItem);
}
impl TMenuItem {
    #[inline]
    pub unsafe fn append(&mut self, aNext: *mut TMenuItem) {
        TMenuItem_append(self, aNext)
    }
    #[inline]
    pub unsafe fn new(
        aName: TStringView,
        aCommand: ushort,
        aKeyCode: ushort,
        aHelpCtx: ushort,
        p: TStringView,
        aNext: *mut TMenuItem,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        TMenuItem_TMenuItem(
            __bindgen_tmp.as_mut_ptr(),
            aName,
            aCommand,
            aKeyCode,
            aHelpCtx,
            p,
            aNext,
        );
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(
        aName: TStringView,
        aKeyCode: ushort,
        aSubMenu: *mut TMenu,
        aHelpCtx: ushort,
        aNext: *mut TMenuItem,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        TMenuItem_TMenuItem1(
            __bindgen_tmp.as_mut_ptr(),
            aName,
            aKeyCode,
            aSubMenu,
            aHelpCtx,
            aNext,
        );
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        TMenuItem_TMenuItem_destructor(self)
    }
}
#[repr(C)]
pub struct TSubMenu {
    pub _base: TMenuItem,
}
#[test]
fn bindgen_test_layout_TSubMenu() {
    assert_eq!(
        ::std::mem::size_of::<TSubMenu>(),
        32usize,
        concat!("Size of: ", stringify!(TSubMenu))
    );
    assert_eq!(
        ::std::mem::align_of::<TSubMenu>(),
        8usize,
        concat!("Alignment of ", stringify!(TSubMenu))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN8TSubMenuC1E11TStringViewtt"]
    pub fn TSubMenu_TSubMenu(this: *mut TSubMenu, nm: TStringView, key: ushort, helpCtx: ushort);
}
impl TSubMenu {
    #[inline]
    pub unsafe fn new(nm: TStringView, key: ushort, helpCtx: ushort) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        TSubMenu_TSubMenu(__bindgen_tmp.as_mut_ptr(), nm, key, helpCtx);
        __bindgen_tmp.assume_init()
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct TMenuView {
    pub _base: TView,
    pub parentMenu: *mut TMenuView,
    pub menu: *mut TMenu,
    pub current: *mut TMenuItem,
    pub putClickEventOnExit: Boolean,
}
extern "C" {
    #[link_name = "\u{1}_ZN9TMenuView4nameE"]
    pub static TMenuView_name: *const ::std::os::raw::c_char;
}
#[test]
fn bindgen_test_layout_TMenuView() {
    assert_eq!(
        ::std::mem::size_of::<TMenuView>(),
        112usize,
        concat!("Size of: ", stringify!(TMenuView))
    );
    assert_eq!(
        ::std::mem::align_of::<TMenuView>(),
        8usize,
        concat!("Alignment of ", stringify!(TMenuView))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TMenuView>())).parentMenu as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(TMenuView),
            "::",
            stringify!(parentMenu)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TMenuView>())).menu as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(TMenuView),
            "::",
            stringify!(menu)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TMenuView>())).current as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(TMenuView),
            "::",
            stringify!(current)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TMenuView>())).putClickEventOnExit as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(TMenuView),
            "::",
            stringify!(putClickEventOnExit)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN9TMenuView8findItemEc"]
    pub fn TMenuView_findItem(this: *mut TMenuView, ch: ::std::os::raw::c_char) -> *mut TMenuItem;
}
extern "C" {
    #[link_name = "\u{1}_ZN9TMenuView6hotKeyEt"]
    pub fn TMenuView_hotKey(this: *mut TMenuView, keyCode: ushort) -> *mut TMenuItem;
}
extern "C" {
    #[link_name = "\u{1}_ZN9TMenuView10newSubViewERK5TRectP5TMenuPS_"]
    pub fn TMenuView_newSubView(
        this: *mut TMenuView,
        bounds: *const TRect,
        aMenu: *mut TMenu,
        aParentMenu: *mut TMenuView,
    ) -> *mut TMenuView;
}
extern "C" {
    #[link_name = "\u{1}_ZN9TMenuView5buildEv"]
    pub fn TMenuView_build() -> *mut TStreamable;
}
extern "C" {
    #[link_name = "\u{1}_ZN9TMenuViewC1ERK5TRectP5TMenuPS_"]
    pub fn TMenuView_TMenuView(
        this: *mut TMenuView,
        bounds: *const TRect,
        aMenu: *mut TMenu,
        aParent: *mut TMenuView,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN9TMenuViewC1ERK5TRect"]
    pub fn TMenuView_TMenuView1(this: *mut TMenuView, bounds: *const TRect);
}
extern "C" {
    #[link_name = "\u{1}_ZN9TMenuViewC1E14StreamableInit"]
    pub fn TMenuView_TMenuView2(this: *mut TMenuView, arg1: StreamableInit);
}
impl TMenuView {
    #[inline]
    pub unsafe fn findItem(&mut self, ch: ::std::os::raw::c_char) -> *mut TMenuItem {
        TMenuView_findItem(self, ch)
    }
    #[inline]
    pub unsafe fn hotKey(&mut self, keyCode: ushort) -> *mut TMenuItem {
        TMenuView_hotKey(self, keyCode)
    }
    #[inline]
    pub unsafe fn newSubView(
        &mut self,
        bounds: *const TRect,
        aMenu: *mut TMenu,
        aParentMenu: *mut TMenuView,
    ) -> *mut TMenuView {
        TMenuView_newSubView(self, bounds, aMenu, aParentMenu)
    }
    #[inline]
    pub unsafe fn build() -> *mut TStreamable {
        TMenuView_build()
    }
    #[inline]
    pub unsafe fn new(bounds: *const TRect, aMenu: *mut TMenu, aParent: *mut TMenuView) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        TMenuView_TMenuView(__bindgen_tmp.as_mut_ptr(), bounds, aMenu, aParent);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(bounds: *const TRect) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        TMenuView_TMenuView1(__bindgen_tmp.as_mut_ptr(), bounds);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new2(arg1: StreamableInit) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        TMenuView_TMenuView2(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN9TMenuView7executeEv"]
    pub fn TMenuView_execute(this: *mut ::std::os::raw::c_void) -> ushort;
}
extern "C" {
    #[link_name = "\u{1}_ZN9TMenuView11getItemRectEP9TMenuItem"]
    pub fn TMenuView_getItemRect(this: *mut ::std::os::raw::c_void, item: *mut TMenuItem) -> TRect;
}
extern "C" {
    #[link_name = "\u{1}_ZN9TMenuView10getHelpCtxEv"]
    pub fn TMenuView_getHelpCtx(this: *mut ::std::os::raw::c_void) -> ushort;
}
extern "C" {
    #[link_name = "\u{1}_ZNK9TMenuView10getPaletteEv"]
    pub fn TMenuView_getPalette(this: *mut ::std::os::raw::c_void) -> *mut TPalette;
}
extern "C" {
    #[link_name = "\u{1}_ZN9TMenuView11handleEventER6TEvent"]
    pub fn TMenuView_handleEvent(this: *mut ::std::os::raw::c_void, event: *mut TEvent);
}
extern "C" {
    #[link_name = "\u{1}_ZThn8_N9TMenuView5writeER8opstream"]
    pub fn TMenuView_write(this: *mut ::std::os::raw::c_void, arg1: *mut opstream);
}
extern "C" {
    #[link_name = "\u{1}_ZThn8_N9TMenuView4readER8ipstream"]
    pub fn TMenuView_read(
        this: *mut ::std::os::raw::c_void,
        arg1: *mut ipstream,
    ) -> *mut ::std::os::raw::c_void;
}
#[repr(C)]
#[derive(Debug)]
pub struct TMenuBar {
    pub _base: TMenuView,
}
extern "C" {
    #[link_name = "\u{1}_ZN8TMenuBar4nameE"]
    pub static TMenuBar_name: *const ::std::os::raw::c_char;
}
#[test]
fn bindgen_test_layout_TMenuBar() {
    assert_eq!(
        ::std::mem::size_of::<TMenuBar>(),
        112usize,
        concat!("Size of: ", stringify!(TMenuBar))
    );
    assert_eq!(
        ::std::mem::align_of::<TMenuBar>(),
        8usize,
        concat!("Alignment of ", stringify!(TMenuBar))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN8TMenuBar5buildEv"]
    pub fn TMenuBar_build() -> *mut TStreamable;
}
extern "C" {
    #[link_name = "\u{1}_ZN8TMenuBarC1ERK5TRectP5TMenu"]
    pub fn TMenuBar_TMenuBar(this: *mut TMenuBar, bounds: *const TRect, aMenu: *mut TMenu);
}
extern "C" {
    #[link_name = "\u{1}_ZN8TMenuBarC1ERK5TRectR8TSubMenu"]
    pub fn TMenuBar_TMenuBar1(this: *mut TMenuBar, bounds: *const TRect, aMenu: *mut TSubMenu);
}
extern "C" {
    #[link_name = "\u{1}_ZN8TMenuBarC1E14StreamableInit"]
    pub fn TMenuBar_TMenuBar2(this: *mut TMenuBar, arg1: StreamableInit);
}
impl TMenuBar {
    #[inline]
    pub unsafe fn build() -> *mut TStreamable {
        TMenuBar_build()
    }
    #[inline]
    pub unsafe fn new(bounds: *const TRect, aMenu: *mut TMenu) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        TMenuBar_TMenuBar(__bindgen_tmp.as_mut_ptr(), bounds, aMenu);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(bounds: *const TRect, aMenu: *mut TSubMenu) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        TMenuBar_TMenuBar1(__bindgen_tmp.as_mut_ptr(), bounds, aMenu);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new2(arg1: StreamableInit) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        TMenuBar_TMenuBar2(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN8TMenuBarD1Ev"]
    pub fn TMenuBar_TMenuBar_destructor(this: *mut TMenuBar);
}
extern "C" {
    #[link_name = "\u{1}_ZN8TMenuBar4drawEv"]
    pub fn TMenuBar_draw(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[link_name = "\u{1}_ZN8TMenuBar11getItemRectEP9TMenuItem"]
    pub fn TMenuBar_getItemRect(this: *mut ::std::os::raw::c_void, item: *mut TMenuItem) -> TRect;
}
#[repr(C)]
#[derive(Debug)]
pub struct TStatusItem {
    pub next: *mut TStatusItem,
    pub text: *mut ::std::os::raw::c_char,
    pub keyCode: ushort,
    pub command: ushort,
}
#[test]
fn bindgen_test_layout_TStatusItem() {
    assert_eq!(
        ::std::mem::size_of::<TStatusItem>(),
        24usize,
        concat!("Size of: ", stringify!(TStatusItem))
    );
    assert_eq!(
        ::std::mem::align_of::<TStatusItem>(),
        8usize,
        concat!("Alignment of ", stringify!(TStatusItem))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TStatusItem>())).next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TStatusItem),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TStatusItem>())).text as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(TStatusItem),
            "::",
            stringify!(text)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TStatusItem>())).keyCode as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(TStatusItem),
            "::",
            stringify!(keyCode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TStatusItem>())).command as *const _ as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(TStatusItem),
            "::",
            stringify!(command)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN11TStatusItemC1E11TStringViewttPS_"]
    pub fn TStatusItem_TStatusItem(
        this: *mut TStatusItem,
        aText: TStringView,
        key: ushort,
        cmd: ushort,
        aNext: *mut TStatusItem,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN11TStatusItemD1Ev"]
    pub fn TStatusItem_TStatusItem_destructor(this: *mut TStatusItem);
}
impl TStatusItem {
    #[inline]
    pub unsafe fn new(
        aText: TStringView,
        key: ushort,
        cmd: ushort,
        aNext: *mut TStatusItem,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        TStatusItem_TStatusItem(__bindgen_tmp.as_mut_ptr(), aText, key, cmd, aNext);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        TStatusItem_TStatusItem_destructor(self)
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TStatusDef {
    pub next: *mut TStatusDef,
    pub min: ushort,
    pub max: ushort,
    pub items: *mut TStatusItem,
}
#[test]
fn bindgen_test_layout_TStatusDef() {
    assert_eq!(
        ::std::mem::size_of::<TStatusDef>(),
        24usize,
        concat!("Size of: ", stringify!(TStatusDef))
    );
    assert_eq!(
        ::std::mem::align_of::<TStatusDef>(),
        8usize,
        concat!("Alignment of ", stringify!(TStatusDef))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TStatusDef>())).next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TStatusDef),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TStatusDef>())).min as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(TStatusDef),
            "::",
            stringify!(min)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TStatusDef>())).max as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(TStatusDef),
            "::",
            stringify!(max)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TStatusDef>())).items as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(TStatusDef),
            "::",
            stringify!(items)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN10TStatusDefC1EttP11TStatusItemPS_"]
    pub fn TStatusDef_TStatusDef(
        this: *mut TStatusDef,
        aMin: ushort,
        aMax: ushort,
        someItems: *mut TStatusItem,
        aNext: *mut TStatusDef,
    );
}
impl TStatusDef {
    #[inline]
    pub unsafe fn new(
        aMin: ushort,
        aMax: ushort,
        someItems: *mut TStatusItem,
        aNext: *mut TStatusDef,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        TStatusDef_TStatusDef(__bindgen_tmp.as_mut_ptr(), aMin, aMax, someItems, aNext);
        __bindgen_tmp.assume_init()
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct TStatusLine {
    pub _base: TView,
    pub items: *mut TStatusItem,
    pub defs: *mut TStatusDef,
}
extern "C" {
    #[link_name = "\u{1}_ZN11TStatusLine13hintSeparatorE"]
    pub static mut TStatusLine_hintSeparator: *const ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_ZN11TStatusLine4nameE"]
    pub static TStatusLine_name: *const ::std::os::raw::c_char;
}
#[test]
fn bindgen_test_layout_TStatusLine() {
    assert_eq!(
        ::std::mem::size_of::<TStatusLine>(),
        96usize,
        concat!("Size of: ", stringify!(TStatusLine))
    );
    assert_eq!(
        ::std::mem::align_of::<TStatusLine>(),
        8usize,
        concat!("Alignment of ", stringify!(TStatusLine))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TStatusLine>())).items as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(TStatusLine),
            "::",
            stringify!(items)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TStatusLine>())).defs as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(TStatusLine),
            "::",
            stringify!(defs)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN11TStatusLine6updateEv"]
    pub fn TStatusLine_update(this: *mut TStatusLine);
}
extern "C" {
    #[link_name = "\u{1}_ZN11TStatusLine5buildEv"]
    pub fn TStatusLine_build() -> *mut TStreamable;
}
extern "C" {
    #[link_name = "\u{1}_ZN11TStatusLineC1ERK5TRectR10TStatusDef"]
    pub fn TStatusLine_TStatusLine(
        this: *mut TStatusLine,
        bounds: *const TRect,
        aDefs: *mut TStatusDef,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN11TStatusLineC1E14StreamableInit"]
    pub fn TStatusLine_TStatusLine1(this: *mut TStatusLine, arg1: StreamableInit);
}
impl TStatusLine {
    #[inline]
    pub unsafe fn update(&mut self) {
        TStatusLine_update(self)
    }
    #[inline]
    pub unsafe fn build() -> *mut TStreamable {
        TStatusLine_build()
    }
    #[inline]
    pub unsafe fn new(bounds: *const TRect, aDefs: *mut TStatusDef) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        TStatusLine_TStatusLine(__bindgen_tmp.as_mut_ptr(), bounds, aDefs);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(arg1: StreamableInit) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        TStatusLine_TStatusLine1(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN11TStatusLineD1Ev"]
    pub fn TStatusLine_TStatusLine_destructor(this: *mut TStatusLine);
}
extern "C" {
    #[link_name = "\u{1}_ZN11TStatusLine4drawEv"]
    pub fn TStatusLine_draw(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[link_name = "\u{1}_ZNK11TStatusLine10getPaletteEv"]
    pub fn TStatusLine_getPalette(this: *mut ::std::os::raw::c_void) -> *mut TPalette;
}
extern "C" {
    #[link_name = "\u{1}_ZN11TStatusLine11handleEventER6TEvent"]
    pub fn TStatusLine_handleEvent(this: *mut ::std::os::raw::c_void, event: *mut TEvent);
}
extern "C" {
    #[link_name = "\u{1}_ZN11TStatusLine4hintEt"]
    pub fn TStatusLine_hint(
        this: *mut ::std::os::raw::c_void,
        aHelpCtx: ushort,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_ZThn8_N11TStatusLine5writeER8opstream"]
    pub fn TStatusLine_write(this: *mut ::std::os::raw::c_void, arg1: *mut opstream);
}
extern "C" {
    #[link_name = "\u{1}_ZThn8_N11TStatusLine4readER8ipstream"]
    pub fn TStatusLine_read(
        this: *mut ::std::os::raw::c_void,
        arg1: *mut ipstream,
    ) -> *mut ::std::os::raw::c_void;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TBackground {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TDeskInit {
    pub createBackground:
        ::std::option::Option<unsafe extern "C" fn(arg1: TRect) -> *mut TBackground>,
}
#[test]
fn bindgen_test_layout_TDeskInit() {
    assert_eq!(
        ::std::mem::size_of::<TDeskInit>(),
        8usize,
        concat!("Size of: ", stringify!(TDeskInit))
    );
    assert_eq!(
        ::std::mem::align_of::<TDeskInit>(),
        8usize,
        concat!("Alignment of ", stringify!(TDeskInit))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TDeskInit>())).createBackground as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TDeskInit),
            "::",
            stringify!(createBackground)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN9TDeskInitC1EPFP11TBackground5TRectE"]
    pub fn TDeskInit_TDeskInit(
        this: *mut TDeskInit,
        cBackground: ::std::option::Option<unsafe extern "C" fn(arg1: TRect) -> *mut TBackground>,
    );
}
impl TDeskInit {
    #[inline]
    pub unsafe fn new(
        cBackground: ::std::option::Option<unsafe extern "C" fn(arg1: TRect) -> *mut TBackground>,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        TDeskInit_TDeskInit(__bindgen_tmp.as_mut_ptr(), cBackground);
        __bindgen_tmp.assume_init()
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct TDeskTop {
    pub _base: TGroup,
    pub background: *mut TBackground,
    pub tileColumnsFirst: Boolean,
    pub __bindgen_padding_0: u64,
}
extern "C" {
    #[link_name = "\u{1}_ZN8TDeskTop13defaultBkgrndE"]
    pub static TDeskTop_defaultBkgrnd: ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_ZN8TDeskTop4nameE"]
    pub static TDeskTop_name: *const ::std::os::raw::c_char;
}
#[test]
fn bindgen_test_layout_TDeskTop() {
    assert_eq!(
        ::std::mem::size_of::<TDeskTop>(),
        160usize,
        concat!("Size of: ", stringify!(TDeskTop))
    );
    assert_eq!(
        ::std::mem::align_of::<TDeskTop>(),
        8usize,
        concat!("Alignment of ", stringify!(TDeskTop))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TDeskTop>())).background as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(TDeskTop),
            "::",
            stringify!(background)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TDeskTop>())).tileColumnsFirst as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(TDeskTop),
            "::",
            stringify!(tileColumnsFirst)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN8TDeskTop7cascadeERK5TRect"]
    pub fn TDeskTop_cascade(this: *mut TDeskTop, arg1: *const TRect);
}
extern "C" {
    #[link_name = "\u{1}_ZN8TDeskTop14initBackgroundE5TRect"]
    pub fn TDeskTop_initBackground(arg1: TRect) -> *mut TBackground;
}
extern "C" {
    #[link_name = "\u{1}_ZN8TDeskTop4tileERK5TRect"]
    pub fn TDeskTop_tile(this: *mut TDeskTop, arg1: *const TRect);
}
extern "C" {
    #[link_name = "\u{1}_ZN8TDeskTop5buildEv"]
    pub fn TDeskTop_build() -> *mut TStreamable;
}
extern "C" {
    #[link_name = "\u{1}_ZN8TDeskTopC1ERK5TRect"]
    pub fn TDeskTop_TDeskTop(this: *mut TDeskTop, arg1: *const TRect);
}
extern "C" {
    #[link_name = "\u{1}_ZN8TDeskTopC1E14StreamableInit"]
    pub fn TDeskTop_TDeskTop1(this: *mut TDeskTop, arg1: StreamableInit);
}
impl TDeskTop {
    #[inline]
    pub unsafe fn cascade(&mut self, arg1: *const TRect) {
        TDeskTop_cascade(self, arg1)
    }
    #[inline]
    pub unsafe fn initBackground(arg1: TRect) -> *mut TBackground {
        TDeskTop_initBackground(arg1)
    }
    #[inline]
    pub unsafe fn tile(&mut self, arg1: *const TRect) {
        TDeskTop_tile(self, arg1)
    }
    #[inline]
    pub unsafe fn build() -> *mut TStreamable {
        TDeskTop_build()
    }
    #[inline]
    pub unsafe fn new(arg1: *const TRect) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        TDeskTop_TDeskTop(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(arg1: StreamableInit) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        TDeskTop_TDeskTop1(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN8TDeskTop11handleEventER6TEvent"]
    pub fn TDeskTop_handleEvent(this: *mut ::std::os::raw::c_void, arg1: *mut TEvent);
}
extern "C" {
    #[link_name = "\u{1}_ZN8TDeskTop9tileErrorEv"]
    pub fn TDeskTop_tileError(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[link_name = "\u{1}_ZN8TDeskTop8shutDownEv"]
    pub fn TDeskTop_shutDown(this: *mut ::std::os::raw::c_void);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TProgInit {
    pub createStatusLine:
        ::std::option::Option<unsafe extern "C" fn(arg1: TRect) -> *mut TStatusLine>,
    pub createMenuBar: ::std::option::Option<unsafe extern "C" fn(arg1: TRect) -> *mut TMenuBar>,
    pub createDeskTop: ::std::option::Option<unsafe extern "C" fn(arg1: TRect) -> *mut TDeskTop>,
}
#[test]
fn bindgen_test_layout_TProgInit() {
    assert_eq!(
        ::std::mem::size_of::<TProgInit>(),
        24usize,
        concat!("Size of: ", stringify!(TProgInit))
    );
    assert_eq!(
        ::std::mem::align_of::<TProgInit>(),
        8usize,
        concat!("Alignment of ", stringify!(TProgInit))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TProgInit>())).createStatusLine as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TProgInit),
            "::",
            stringify!(createStatusLine)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TProgInit>())).createMenuBar as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(TProgInit),
            "::",
            stringify!(createMenuBar)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TProgInit>())).createDeskTop as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(TProgInit),
            "::",
            stringify!(createDeskTop)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN9TProgInitC1EPFP11TStatusLine5TRectEPFP8TMenuBarS2_EPFP8TDeskTopS2_E"]
    pub fn TProgInit_TProgInit(
        this: *mut TProgInit,
        cStatusLine: ::std::option::Option<unsafe extern "C" fn(arg1: TRect) -> *mut TStatusLine>,
        cMenuBar: ::std::option::Option<unsafe extern "C" fn(arg1: TRect) -> *mut TMenuBar>,
        cDeskTop: ::std::option::Option<unsafe extern "C" fn(arg1: TRect) -> *mut TDeskTop>,
    );
}
impl TProgInit {
    #[inline]
    pub unsafe fn new(
        cStatusLine: ::std::option::Option<unsafe extern "C" fn(arg1: TRect) -> *mut TStatusLine>,
        cMenuBar: ::std::option::Option<unsafe extern "C" fn(arg1: TRect) -> *mut TMenuBar>,
        cDeskTop: ::std::option::Option<unsafe extern "C" fn(arg1: TRect) -> *mut TDeskTop>,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        TProgInit_TProgInit(__bindgen_tmp.as_mut_ptr(), cStatusLine, cMenuBar, cDeskTop);
        __bindgen_tmp.assume_init()
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct TProgram {
    pub _base: TGroup,
    pub __bindgen_padding_0: [u64; 3usize],
}
extern "C" {
    #[link_name = "\u{1}_ZN8TProgram11applicationE"]
    pub static mut TProgram_application: *mut TProgram;
}
extern "C" {
    #[link_name = "\u{1}_ZN8TProgram10statusLineE"]
    pub static mut TProgram_statusLine: *mut TStatusLine;
}
extern "C" {
    #[link_name = "\u{1}_ZN8TProgram7menuBarE"]
    pub static mut TProgram_menuBar: *mut TMenuBar;
}
extern "C" {
    #[link_name = "\u{1}_ZN8TProgram7deskTopE"]
    pub static mut TProgram_deskTop: *mut TDeskTop;
}
extern "C" {
    #[link_name = "\u{1}_ZN8TProgram10appPaletteE"]
    pub static mut TProgram_appPalette: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZN8TProgram7pendingE"]
    pub static mut TProgram_pending: TEvent;
}
extern "C" {
    #[link_name = "\u{1}_ZN8TProgram8exitTextE"]
    pub static mut TProgram_exitText: *const ::std::os::raw::c_char;
}
#[test]
fn bindgen_test_layout_TProgram() {
    assert_eq!(
        ::std::mem::size_of::<TProgram>(),
        160usize,
        concat!("Size of: ", stringify!(TProgram))
    );
    assert_eq!(
        ::std::mem::align_of::<TProgram>(),
        8usize,
        concat!("Alignment of ", stringify!(TProgram))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN8TProgram13setScreenModeEt"]
    pub fn TProgram_setScreenMode(this: *mut TProgram, mode: ushort);
}
extern "C" {
    #[link_name = "\u{1}_ZN8TProgram9validViewEP5TView"]
    pub fn TProgram_validView(this: *mut TProgram, p: *mut TView) -> *mut TView;
}
extern "C" {
    #[link_name = "\u{1}_ZN8TProgram14initStatusLineE5TRect"]
    pub fn TProgram_initStatusLine(arg1: TRect) -> *mut TStatusLine;
}
extern "C" {
    #[link_name = "\u{1}_ZN8TProgram11initMenuBarE5TRect"]
    pub fn TProgram_initMenuBar(arg1: TRect) -> *mut TMenuBar;
}
extern "C" {
    #[link_name = "\u{1}_ZN8TProgram11initDeskTopE5TRect"]
    pub fn TProgram_initDeskTop(arg1: TRect) -> *mut TDeskTop;
}
extern "C" {
    #[link_name = "\u{1}_ZN8TProgramC1Ev"]
    pub fn TProgram_TProgram(this: *mut TProgram);
}
impl TProgram {
    #[inline]
    pub unsafe fn setScreenMode(&mut self, mode: ushort) {
        TProgram_setScreenMode(self, mode)
    }
    #[inline]
    pub unsafe fn validView(&mut self, p: *mut TView) -> *mut TView {
        TProgram_validView(self, p)
    }
    #[inline]
    pub unsafe fn initStatusLine(arg1: TRect) -> *mut TStatusLine {
        TProgram_initStatusLine(arg1)
    }
    #[inline]
    pub unsafe fn initMenuBar(arg1: TRect) -> *mut TMenuBar {
        TProgram_initMenuBar(arg1)
    }
    #[inline]
    pub unsafe fn initDeskTop(arg1: TRect) -> *mut TDeskTop {
        TProgram_initDeskTop(arg1)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        TProgram_TProgram(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN8TProgramD1Ev"]
    pub fn TProgram_TProgram_destructor(this: *mut TProgram);
}
extern "C" {
    #[link_name = "\u{1}_ZN8TProgram12canMoveFocusEv"]
    pub fn TProgram_canMoveFocus(this: *mut ::std::os::raw::c_void) -> Boolean;
}
extern "C" {
    #[link_name = "\u{1}_ZN8TProgram13executeDialogEP7TDialogPv"]
    pub fn TProgram_executeDialog(
        this: *mut ::std::os::raw::c_void,
        arg1: *mut TDialog,
        data: *mut ::std::os::raw::c_void,
    ) -> ushort;
}
extern "C" {
    #[link_name = "\u{1}_ZN8TProgram8getEventER6TEvent"]
    pub fn TProgram_getEvent(this: *mut ::std::os::raw::c_void, event: *mut TEvent);
}
extern "C" {
    #[link_name = "\u{1}_ZNK8TProgram10getPaletteEv"]
    pub fn TProgram_getPalette(this: *mut ::std::os::raw::c_void) -> *mut TPalette;
}
extern "C" {
    #[link_name = "\u{1}_ZN8TProgram11handleEventER6TEvent"]
    pub fn TProgram_handleEvent(this: *mut ::std::os::raw::c_void, event: *mut TEvent);
}
extern "C" {
    #[link_name = "\u{1}_ZN8TProgram4idleEv"]
    pub fn TProgram_idle(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[link_name = "\u{1}_ZN8TProgram10initScreenEv"]
    pub fn TProgram_initScreen(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[link_name = "\u{1}_ZN8TProgram11outOfMemoryEv"]
    pub fn TProgram_outOfMemory(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[link_name = "\u{1}_ZN8TProgram8putEventER6TEvent"]
    pub fn TProgram_putEvent(this: *mut ::std::os::raw::c_void, event: *mut TEvent);
}
extern "C" {
    #[link_name = "\u{1}_ZN8TProgram9textEventER6TEvent5TSpanIcERmS4_"]
    pub fn TProgram_textEvent(
        this: *mut ::std::os::raw::c_void,
        event: *mut TEvent,
        dest: TSpan<::std::os::raw::c_char>,
        length: *mut size_t,
        count: *mut size_t,
    ) -> Boolean;
}
extern "C" {
    #[link_name = "\u{1}_ZN8TProgram3runEv"]
    pub fn TProgram_run(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[link_name = "\u{1}_ZN8TProgram12insertWindowEP7TWindow"]
    pub fn TProgram_insertWindow(
        this: *mut ::std::os::raw::c_void,
        arg1: *mut TWindow,
    ) -> *mut TWindow;
}
extern "C" {
    #[link_name = "\u{1}_ZN8TProgram8shutDownEv"]
    pub fn TProgram_shutDown(this: *mut ::std::os::raw::c_void);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TStaticInit {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_TStaticInit() {
    assert_eq!(
        ::std::mem::size_of::<TStaticInit>(),
        1usize,
        concat!("Size of: ", stringify!(TStaticInit))
    );
    assert_eq!(
        ::std::mem::align_of::<TStaticInit>(),
        1usize,
        concat!("Alignment of ", stringify!(TStaticInit))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN11TStaticInitC1Ev"]
    pub fn TStaticInit_TStaticInit(this: *mut TStaticInit);
}
impl TStaticInit {
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        TStaticInit_TStaticInit(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct TApplication {
    pub _base: TProgram,
}
#[test]
fn bindgen_test_layout_TApplication() {
    assert_eq!(
        ::std::mem::size_of::<TApplication>(),
        160usize,
        concat!("Size of: ", stringify!(TApplication))
    );
    assert_eq!(
        ::std::mem::align_of::<TApplication>(),
        8usize,
        concat!("Alignment of ", stringify!(TApplication))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN12TApplication7cascadeEv"]
    pub fn TApplication_cascade(this: *mut TApplication);
}
extern "C" {
    #[link_name = "\u{1}_ZN12TApplication8dosShellEv"]
    pub fn TApplication_dosShell(this: *mut TApplication);
}
extern "C" {
    #[link_name = "\u{1}_ZN12TApplication4tileEv"]
    pub fn TApplication_tile(this: *mut TApplication);
}
extern "C" {
    #[link_name = "\u{1}_ZN12TApplicationC1Ev"]
    pub fn TApplication_TApplication(this: *mut TApplication);
}
impl TApplication {
    #[inline]
    pub unsafe fn cascade(&mut self) {
        TApplication_cascade(self)
    }
    #[inline]
    pub unsafe fn dosShell(&mut self) {
        TApplication_dosShell(self)
    }
    #[inline]
    pub unsafe fn tile(&mut self) {
        TApplication_tile(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        TApplication_TApplication(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN12TApplicationD1Ev"]
    pub fn TApplication_TApplication_destructor(this: *mut TApplication);
}
extern "C" {
    #[link_name = "\u{1}_ZN12TApplication7suspendEv"]
    pub fn TApplication_suspend(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[link_name = "\u{1}_ZN12TApplication6resumeEv"]
    pub fn TApplication_resume(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[link_name = "\u{1}_ZN12TApplication11getTileRectEv"]
    pub fn TApplication_getTileRect(this: *mut ::std::os::raw::c_void) -> TRect;
}
extern "C" {
    #[link_name = "\u{1}_ZN12TApplication11handleEventER6TEvent"]
    pub fn TApplication_handleEvent(this: *mut ::std::os::raw::c_void, event: *mut TEvent);
}
extern "C" {
    #[link_name = "\u{1}_ZN12TApplication13writeShellMsgEv"]
    pub fn TApplication_writeShellMsg(this: *mut ::std::os::raw::c_void);
}
#[test]
fn __bindgen_test_layout_trivially_convertible_open0_uint16_t_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<trivially_convertible>(),
        2usize,
        concat!(
            "Size of template specialization: ",
            stringify!(trivially_convertible)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<trivially_convertible>(),
        2usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(trivially_convertible)
        )
    );
}
#[test]
fn __bindgen_test_layout_TSpan_open0_TScreenCell_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<TSpan<TScreenCell>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(TSpan<TScreenCell>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<TSpan<TScreenCell>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(TSpan<TScreenCell>)
        )
    );
}
#[test]
fn __bindgen_test_layout_TSpan_open0_TScreenCell_close0_instantiation_1() {
    assert_eq!(
        ::std::mem::size_of::<TSpan<TScreenCell>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(TSpan<TScreenCell>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<TSpan<TScreenCell>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(TSpan<TScreenCell>)
        )
    );
}
#[test]
fn __bindgen_test_layout_TSpan_open0_char_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<TSpan<::std::os::raw::c_char>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(TSpan<::std::os::raw::c_char>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<TSpan<::std::os::raw::c_char>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(TSpan<::std::os::raw::c_char>)
        )
    );
}
#[test]
fn __bindgen_test_layout_TSpan_open0_char_close0_instantiation_1() {
    assert_eq!(
        ::std::mem::size_of::<TSpan<::std::os::raw::c_char>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(TSpan<::std::os::raw::c_char>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<TSpan<::std::os::raw::c_char>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(TSpan<::std::os::raw::c_char>)
        )
    );
}
#[test]
fn __bindgen_test_layout_TSpan_open0_char_close0_instantiation_2() {
    assert_eq!(
        ::std::mem::size_of::<TSpan<::std::os::raw::c_char>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(TSpan<::std::os::raw::c_char>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<TSpan<::std::os::raw::c_char>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(TSpan<::std::os::raw::c_char>)
        )
    );
}
